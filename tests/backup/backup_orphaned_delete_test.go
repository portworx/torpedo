package tests

import (
	"fmt"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// 1557-T2
// DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin deletes user backups and restores of the deleted and inactive cluster from the admin
var _ = Describe("{DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87569

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		infraAdminUsers                            = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		userRestoreMap                             = make(map[string]map[string]string)
		numberOfUsers                              = 1
		numberOfBackups                            = 1
		invalidKubeconfig                          = "\"\""
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		deleteUserClusters                         = false
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin", "Delete user backups and restores of the deleted and inactive cluster from the admin", nil, 87569)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes user backups and restores of the deleted and inactive cluster from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		for i := 0; i < 2; i++ {
			Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
				log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
				for _, user := range createUsers(numberOfUsers) {
					err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
					log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
					infraAdminUsers = append(infraAdminUsers, user)
				}
			})
			createObjectsFromUser := func(user string) {
				Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					for _, provider := range providers {
						userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
						userCloudCredentialUID := uuid.New()
						err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
						log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
						userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
						userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
						userBackupLocationUID := uuid.New()
						err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
						log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
						userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
					}
				})
				Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
					clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
					dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
					userClusterMap[user] = make(map[string]string)
					for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
						userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
						userClusterMap[user][clusterName] = userClusterUID
					}
				})
				Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userBackupMap[user] = make(map[string]string)
					createBackup := func(backupName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
						for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
							err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
							break
						}
						mu.Lock()
						defer mu.Unlock()
						userBackupMap[user][backupName] = namespace
					}
					for _, namespace := range appNamespaces {
						for i := 0; i < numberOfBackups; i++ {
							backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
							wg.Add(1)
							go createBackup(backupName, namespace)
						}
					}
					wg.Wait()
					log.Infof("The list of user backups taken are: %v", userBackupMap)
				})
				Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
					for backupName := range userBackupMap[user] {
						if !IsPresent(backupNamesByOwnerID, backupName) {
							err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
			}
			err := TaskHandler([]string{infraAdminUsers[i]}, createObjectsFromUser, Parallel)
			log.FailOnError(err, "failed to create objects from user")
			for _, user := range []string{infraAdminUsers[i]} {
				Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userRestoreMap[user] = make(map[string]string, 0)
					createRestore := func(backupName string, restoreName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
						namespaceMapping := map[string]string{namespace: customNamespace}
						err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
						restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
						log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
						mu.Lock()
						defer mu.Unlock()
						userRestoreMap[user][restoreUid] = restoreName
					}
					for backupName, namespace := range userBackupMap[user] {
						wg.Add(1)
						restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
						go createRestore(backupName, restoreName, namespace)
					}
					wg.Wait()
					log.Infof("The list of user restores taken are: %v", userRestoreMap)
				})
				Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
					for _, restoreName := range userRestoreMap[user] {
						if !IsPresent(restoreNamesByOwnerID, restoreName) {
							err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
				if i == 0 {
					Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
						log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, nonAdminCtx, false)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
						}
					})
				} else {
					deleteUserClusters = true
					Step(fmt.Sprintf("Make source and destination cluster inactive from the user %s", user), func() {
						log.InfoD(fmt.Sprintf("Making source and destination cluster inactive from the user %s", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							clusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
							log.FailOnError(err, "failed to fetch cluster %s uid", clusterName)
							clusterUpdateRequest := &api.ClusterUpdateRequest{
								CreateMetadata: &api.CreateMetadata{
									Name:  clusterName,
									Uid:   clusterUID,
									OrgId: orgID,
								},
								Kubeconfig: invalidKubeconfig,
							}
							_, err = Inst().Backup.UpdateCluster(nonAdminCtx, clusterUpdateRequest)
							if err != nil {
								clusterStatus, statusError := Inst().Backup.GetClusterStatus(orgID, clusterName, nonAdminCtx)
								log.FailOnError(statusError, "failed to get cluster status %s", clusterName)
								if clusterStatus != api.ClusterInfo_StatusInfo_Failed {
									log.FailOnError(err, "failed to make cluster %s inactive. Expected status %v but got %v", clusterName, api.ClusterInfo_StatusInfo_Failed, clusterStatus)
								}
							} else {
								err = fmt.Errorf("failed to make cluster %s inactive. Expected error not be nil", clusterName)
								log.FailOnError(fmt.Errorf(""), err.Error())
							}
						}
					})
				}
			}
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			cleanupUserObjectsFromAdmin := func(user string) {
				defer GinkgoRecover()
				Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
					for backupName := range userBackupMap[user] {
						backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
						log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
						_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user][SourceClusterName], orgID, ctx)
						log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					}
				})
				Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
					for restoreUid, restoreName := range userRestoreMap[user] {
						err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, ctx)
						log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
					}
				})
			}
			err = TaskHandler([]string{infraAdminUsers[i]}, cleanupUserObjectsFromAdmin, Parallel)
			log.FailOnError(err, "failed to cleanup user objects from admin")
			if deleteUserClusters {
				for _, user := range []string{infraAdminUsers[i]} {
					Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
						log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, nonAdminCtx, false)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
						}
					})
				}
			}
		}
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err := TaskHandler(infraAdminUsers, cleanupUserObjects, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})
