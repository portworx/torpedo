package tests

import (
	"fmt"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// 1399-T1
// DeleteSharedBackupOfUserFromAdmin deletes backups shared by the user from the admin
var _ = Describe("{DeleteSharedBackupOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87562

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		numberOfBackups                            = 1
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		user1                  string
		user2                  string
		user3                  string
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteSharedBackupOfUserFromAdmin", "Delete backups shared by the user from the admin", nil, 87562)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups shared by the user from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", 3, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", 3, infraAdminRole))
			user1 = createUsers(1)[0]
			err := backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user1))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user1)
			user2 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user2))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user2)
			user3 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user3))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user3)
		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[user1] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[user1] = map[string]string{userBackupLocationUID: userBackupLocationName}
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", user1)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[user1] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[user1][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			userBackupMap[user1] = make(map[string]string)
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user1] {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user1][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userBackupMap[user1][backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of user backups taken are: %v", userBackupMap)
		})
		Step(fmt.Sprintf("Share user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for backupName := range userBackupMap[user1] {
				err := ShareBackup(backupName, nil, []string{user2}, ViewOnlyAccess, nonAdminCtx)
				log.FailOnError(err, "failed to share user %s backup %s [backup-share] with user %s with ViewOnlyAccess", user1, backupName, user2)
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin2Ctx, err := backup.GetNonAdminCtx(user2, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin2Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user2)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Share user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = ClusterUpdateBackupShare(SourceClusterName, nil, []string{user3}, ViewOnlyAccess, true, nonAdminCtx)
			log.FailOnError(err, "failed to share user %s backups %s [cluster-share] with user %s with ViewOnlyAccess", user1, userBackupMap[user1], user3)
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin3Ctx, err := backup.GetNonAdminCtx(user3, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin3Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user3)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the admin", user1), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete the owner [%s] of the backups", user1), func() {
			log.InfoD(fmt.Sprintf("Deleting the owner [%s] of the backups", user1))
			err := backup.DeleteUser(user1)
			log.FailOnError(err, "failed to delete user %s", user1)
		})
		Step(fmt.Sprintf("Delete user %s backups from the admin", user2), func() {
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user2))
			for backupName := range userBackupMap[user1] {
				backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user2)
				_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user2][SourceClusterName], orgID, ctx)
				log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user2)
			}
		})
		Step(fmt.Sprintf("Wait for the backups to be deleted"), func() {
			log.InfoD("Waiting for the backups to be deleted")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			var wg sync.WaitGroup
			for backupName := range userBackupMap[user1] {
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupDeletion(ctx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
					log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
				}(backupName)
			}
			wg.Wait()
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user1] {
			CleanupCloudSettingsAndClusters(userBackupLocationMap[user1], cloudCredentialName, cloudCredentialUID, ctx)
			break
		}
		err = backup.DeleteUser(user2)
		log.FailOnError(err, "failed to delete user %s", user2)
		err = backup.DeleteUser(user3)
		log.FailOnError(err, "failed to delete user %s", user3)
	})
})
