package tests

import (
	"fmt"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// UpdatesBackupOfUserFromAdmin updates backups of non admin user from px-admin with valid/in-valid cloud account.
var _ = Describe("{UpdatesBackupOfUserFromAdmin}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87568
	var scheduledAppContexts []*scheduler.Context
	var backupLocationUID string
	var bkpNamespaces []string
	var credName string
	var cloudCredUID string
	var invalidCloudCredUID string
	var invalidCredName string
	var srcClusterUid string
	var destClusterUid string
	var backupLocationName string
	var nonAdminUserName string
	var providers []string
	var periodicSchedulePolicyName string
	var periodicSchedulePolicyInterval int64
	var periodicSchedulePolicyUid string

	bkpNamespaces = make([]string, 0)
	backupLocationMap := make(map[string]string)
	providers = getProviders()

	JustBeforeEach(func() {
		StartTorpedoTest("UpdatesBackupOfUserFromAdmin",
			"Updates backups of non admin user from px-admin with valid/in-valid account", nil, 87568)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})

	It("Updates Backups and Cluster of user from px-admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step("Create a non-admin user", func() {
			log.InfoD(fmt.Sprintf("Create a non-admin user"))
			nonAdminUserName = createUsers(1)[0]
			err := backup.AddRoleToUser(nonAdminUserName, backup.InfrastructureOwner, fmt.Sprintf("Adding %v role to %s", backup.InfrastructureOwner, nonAdminUserName))
			log.FailOnError(err, "Failed to add role for user - %s", nonAdminUserName)
		})

		Step(fmt.Sprintf("Adding Credentials and Backup Location from non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credentials and backup location from non-adminuser"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non-admin ctx")
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, nonAdminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Create schedule policy from non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating a schedule policy from non-admin [%s] user", nonAdminUserName))
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin user ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%v-%s", "periodic", time.Now().Unix(), nonAdminUserName)
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval = 15
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s] for user [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyName, nonAdminUserName))

		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on %s ", nonAdminUserName), func() {
			log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			destClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
		})

		Step(fmt.Sprintf("Taking manual backup and schedule backup of applications for user %s", nonAdminUserName), func() {
			log.InfoD(fmt.Sprintf("Taking manual backup and schedule backup of applications for user%s", nonAdminUserName))
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			labelSelectors := make(map[string]string, 0)
			backupName := fmt.Sprintf("%s-manual-%s-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
				labelSelectors, orgID, srcClusterUid, "", "", "", "")
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupName))

			scheduleName := fmt.Sprintf("%s-schedule-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
			log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
			appContextsToBackup = FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
				labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyName, periodicSchedulePolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))

		})

		Step("Create invalid credential for cluster and backup object", func() {
			log.InfoD("Create invalid credential for cluster and backup object")
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			invalidCloudCredUID = uuid.New()
			backupLocationUID = uuid.New()
			invalidCredName = fmt.Sprintf("invalid-autogenerated-cred-%v", time.Now().Unix())
			err = createInvalidAWSCloudCredential(invalidCredName, invalidCloudCredUID, orgID, nonAdminCtx)
			log.FailOnError(err, "Failed to create invalid cloud credential - %s", err)
		})

		Step("Verifying listing and updation of backup of non-admin user from px-admin", func() {
			log.InfoD("Verifying listing and updation of backup of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			userUID, err := backup.FetchIDOfUser(nonAdminUserName)
			userBackupNames, err := GetAllBackupsOfUsersFromAdmin([]string{userUID}, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNames))
			for _, backupName := range userBackupNames {
				bkpUid, _ := Inst().Backup.GetBackupUID(adminCtx, backupName, orgID)
				_, err = UpdateBackup(backupName, bkpUid, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of updation of backup [%v] of user [%s] from px-admin user", backupName, nonAdminUserName))
			}
		})

		Step("Verifying deletion of backup of non-admin user from px-admin", func() {
			log.InfoD("Verifying deletion of backup of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching admin ctx")
			userUID, err := backup.FetchIDOfUser(nonAdminUserName)
			userBackupNames, err := GetAllBackupsOfUsersFromAdmin([]string{userUID}, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNames))
			for _, backupName := range userBackupNames {
				backupUID, _ := Inst().Backup.GetBackupUID(adminCtx, backupName, orgID)
				_, err = DeleteBackup(backupName, backupUID, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
				err = DeleteBackupAndWait(backupName, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
			}
		})

		Step("Verifying deletion of backup schedule of non-admin user from px-admin", func() {
			log.InfoD("Verifying deletion of backup schedule of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching admin ctx")
			userBackupScheduleNames, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupScheduleNames, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupScheduleNames))
			for _, userBackupScheduleName := range userBackupScheduleNames {
				log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", userBackupScheduleName, nonAdminUserName))
				backupScheduleUid, err := GetScheduleUID(userBackupScheduleName, orgID, adminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", userBackupScheduleName))
				err = DeleteScheduleWithClusterRef(userBackupScheduleName, backupScheduleUid, SourceClusterName, srcClusterUid, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", userBackupScheduleName, nonAdminUserName))
			}
		})

		Step("Verifying updation of cluster of non-admin user from px-admin", func() {
			log.InfoD("Verifying updation of cluster of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			srcClusterConfigPath, err := GetSourceClusterConfigPath()
			log.FailOnError(err, "Fetching source clusterconfigpath")
			_, err = UpdateCluster(SourceClusterName, srcClusterUid, srcClusterConfigPath, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of updation of cluster [%v] of user [%s] from px-admin user", SourceClusterName, nonAdminUserName))
			dstClusterConfigPath, err := GetDestinationClusterConfigPath()
			log.FailOnError(err, "Fetching destination clusterconfigpath")
			_, err = UpdateCluster(destinationClusterName, destClusterUid, dstClusterConfigPath, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of updation of cluster [%v] of user [%s] from px-admin user", destinationClusterName, nonAdminUserName))
		})

		Step(fmt.Sprintf("Verifying  deletion of clusters of non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of clusters of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			err = DeleteClusterWithUid(SourceClusterName, srcClusterUid, orgID, adminCtx, true)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
			err = DeleteClusterWithUid(destinationClusterName, destClusterUid, orgID, adminCtx, true)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.Infof("Deleting backup schedule policy")
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})
