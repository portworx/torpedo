package tests

import (
	"context"
	"fmt"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// 1557-T1
// DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin deletes failed and in-progress backups and restores of user from the admin
var _ = Describe("{DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87564

	var (
		scheduledAppContexts                           = make([]*scheduler.Context, 0)
		appNamespaces                                  = make([]string, 0)
		userCloudCredentialMap                         = make(map[string]string)
		userBackupLocationMap                          = make(map[string]string)
		providers                                      = getProviders()
		userInProgressBackupNames                      = make([]string, 0)
		userFailedBackupNames                          = make([]string, 0)
		userSuccessfulBackupMap                        = make(map[string]string)
		userInProgressRestoreNames                     = make([]string, 0)
		userFailedRestoreNames                         = make([]string, 0)
		deletedUserRestoreMap                          = make(map[string]bool)
		numberOfBackups                                = 1
		invalidNamespace                               = "-"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
		userSourceClusterUID       string
		infraAdminUser             string
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin", "Delete failed and in-progress backups and restores of user from the admin side", nil, 87564)
		log.InfoD("Scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Delete failed and in-progress backups and restores of user from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create user with %s role", infraAdminRole), func() {
			infraAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(infraAdminUser, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, infraAdminUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
			log.Infof("username %s common password %s", infraAdminUser, commonPassword)

		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[userCloudCredentialUID] = userCloudCredentialName
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[userBackupLocationUID] = userBackupLocationName
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", infraAdminUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userSourceClusterUID, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})
		Step(fmt.Sprintf("Take in progress backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{namespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
					userInProgressBackupNames = append(userInProgressBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of in progress user backups taken are: %v", userInProgressBackupNames)
		})
		Step(fmt.Sprintf("Verify in progress backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userInProgressBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("in progress backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress backups taken by user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			backupEnumerateRequest := &api.BackupEnumerateRequest{
				OrgId: orgID,
				EnumerateOptions: &api.EnumerateOptions{
					Owners: []string{userOwnerID},
				},
			}
			deletedUserBackupMap := make(map[string]bool)
			deleteInProgressBackup := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateBackup(ctx, backupEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingBackups := false
				for _, backup := range resp.GetBackups() {
					if IsPresent(userInProgressBackupNames, backup.GetName()) {
						actual := backup.GetStatus().GetStatus()
						switch actual {
						case api.BackupInfo_StatusInfo_InProgress:
							backupName := backup.GetName()
							if _, exists := deletedUserBackupMap[backupName]; exists {
								continue
							}
							wg.Add(1)
							go func(backup *api.BackupObject, ctx context.Context) {
								defer wg.Done()
								_, err := DeleteBackup(backup.GetName(), backup.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(backup, ctx)
							deletedUserBackupMap[backupName] = true
						case api.BackupInfo_StatusInfo_Pending:
							pendingBackups = true
						}
					} else {
						log.Warnf("backup %s with uid %s may not have been created by this testcase", backup.GetName(), backup.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingBackups {
						return "", true, fmt.Errorf("there are pending backups")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressBackup, maxWaitPeriodForBackupJobCancellation*time.Minute, backupJobCancellationRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress backups"))
			dash.VerifyFatal(len(deletedUserBackupMap) > 0, true, "Verifying if there is at least one in progress backup")
		})
		Step(fmt.Sprintf("Take failed backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{invalidNamespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					if err != nil {
						backupUID, UIDError := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
						log.FailOnError(UIDError, "failed to get backup %s uid", backupName)
						backupInspectRequest := &api.BackupInspectRequest{
							Name:  backupName,
							OrgId: orgID,
							Uid:   backupUID,
						}
						resp, inspectError := Inst().Backup.InspectBackup(nonAdminCtx, backupInspectRequest)
						log.FailOnError(inspectError, "failed to inspect backup %s", backupName)
						if resp.GetBackup().GetStatus().GetStatus() != api.BackupInfo_StatusInfo_Failed {
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
						}
					}
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
					userFailedBackupNames = append(userFailedBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of failed user backups taken are: %v", userFailedBackupNames)
		})
		Step(fmt.Sprintf("Verify failed backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userFailedBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("failed backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed backups taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range userFailedBackupNames {
				backupUID, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "failed to fetch backup %s uid", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				log.FailOnError(err, "failed to delete backup %s uid", backupName)
			}
		})
		Step(fmt.Sprintf("Take successful backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking successful backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userSourceClusterUID, "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userSuccessfulBackupMap[backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of successful user backups taken are: %v", userSuccessfulBackupMap)
		})
		Step(fmt.Sprintf("Verify successful backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying successful backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userSuccessfulBackupMap {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("successful backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Take in progress restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: fmt.Sprintf("r-%s-%v", namespace, time.Now().Unix())}
				_, err = CreateRestoreWithoutCheck(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
				mu.Lock()
				defer mu.Unlock()
				userInProgressRestoreNames = append(userInProgressRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of in progress user restores taken are: %v", userInProgressRestoreNames)
		})
		Step(fmt.Sprintf("Verify in progress restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userInProgressRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("in progress restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreEnumerateRequest := &api.RestoreEnumerateRequest{
				OrgId: orgID,
			}
			deleteInProgressRestore := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateRestore(ctx, restoreEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingRestores := false
				for _, restore := range resp.GetRestores() {
					if IsPresent(userInProgressRestoreNames, restore.GetName()) {
						actual := restore.GetStatus().GetStatus()
						switch actual {
						case api.RestoreInfo_StatusInfo_InProgress:
							restoreName := restore.GetName()
							if _, exists := deletedUserRestoreMap[restoreName]; exists {
								continue
							}
							wg.Add(1)
							go func(restore *api.RestoreObject, ctx context.Context) {
								defer wg.Done()
								err := DeleteRestoreWithUID(restore.GetName(), restore.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(restore, ctx)
							deletedUserRestoreMap[restoreName] = true
						case api.RestoreInfo_StatusInfo_Pending:
							pendingRestores = true
						}
					} else {
						log.Warnf("restore %s with uid %s may not have been created by this testcase", restore.GetName(), restore.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingRestores {
						return "", true, fmt.Errorf("there are pending restores")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressRestore, maxWaitPeriodForRestoreJobCancellation*time.Minute, restoreJobProgressRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress restores"))
			dash.VerifyFatal(len(deletedUserRestoreMap) > 0, true, "Verifying if there is at least one in progress restores")
		})
		Step(fmt.Sprintf("Take failed restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: invalidNamespace}
				backupUID, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
				log.FailOnError(err, "failed to get backup %s uid", backupName)
				err = CreateRestoreWithUID(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx, make(map[string]string), backupUID)
				if err != nil {
					restoreUID, UIDError := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(UIDError, "failed to get restore %s uid", restoreName)
					restoreInspectRequest := &api.RestoreInspectRequest{
						Name:  restoreName,
						OrgId: orgID,
						Uid:   restoreUID,
					}
					resp, inspectError := Inst().Backup.InspectRestore(nonAdminCtx, restoreInspectRequest)
					log.FailOnError(inspectError, "failed to inspect restore %s", backupName)
					if resp.GetRestore().GetStatus().GetStatus() != api.RestoreInfo_StatusInfo_Failed {
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					}
				}
				mu.Lock()
				defer mu.Unlock()
				userFailedRestoreNames = append(userFailedRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of failed user restores taken are: %v", userFailedRestoreNames)
		})
		Step(fmt.Sprintf("Verify failed restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userFailedRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("failed restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, restoreName := range userFailedRestoreNames {
				restoreUID, err := Inst().Backup.GetRestoreUID(ctx, restoreName, orgID)
				log.FailOnError(err, "failed to fetch restore %s uid", restoreName)
				err = DeleteRestoreWithUID(restoreName, restoreUID, orgID, ctx)
				log.FailOnError(err, "failed to delete restore %s uid", restoreName)
			}
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
		log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap {
			CleanupCloudSettingsAndClusters(userBackupLocationMap, cloudCredentialName, cloudCredentialUID, nonAdminCtx)
			break
		}
		err = backup.DeleteUser(infraAdminUser)
		log.FailOnError(err, "failed to delete user %s", infraAdminUser)
	})
})
