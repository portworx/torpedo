package tests

import (
	"fmt"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// DeleteBackupSharedByMultipleUsersFromAdmin deletes backups non admin user from px-admin when backup is shared by multiple users.
var _ = Describe("{DeleteBackupSharedByMultipleUsersFromAdmin}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87565

	var (
		scheduledAppContexts           []*scheduler.Context
		backupLocationUID              string
		adminCredName                  string
		userName                       string
		adminCloudCredUID              string
		srcClusterUid                  string
		backupLocationName             string
		periodicSchedulePolicyName     string
		periodicSchedulePolicyInterval int64
		periodicSchedulePolicyUid      string
		appAdminUserName               string
		infraAdminUserName             string
		appUserName                    string
		userNames                      []string
		wg                             sync.WaitGroup
		mutex                          sync.Mutex
		bkpNamespaces                  = make([]string, 0)
		timeBetweenConsecutiveBackups  = 10 * time.Second
		backupLocationMap              = make(map[string]string)
		providers                      = getProviders()
		userIdMap                      = make(map[string]string)
		backupLocationUserMap          = make(map[string]string)
		backupLocationUidUserMap       = make(map[string]string)
		clusterUidMap                  = make(map[string]map[string]string)
		scheduleNameMap                = make(map[string]string)
		userBackupSchedulesMap         = make(map[string][]string)
		userCloudCredentialMap         = make(map[string]map[string]string)
		userBackupLocationMap          = make(map[string]map[string]string)
		userBackupsMap                 = make(map[string][]string)
		backupDriver                   = Inst().Backup
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteBackupSharedByMultipleUsersFromAdmin",
			"Delete backups of non admin user from px-admin when backup is shared by multiple users", nil, 87565)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})

	It("Delete backups of non admin user from px-admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step("Create a non-admin users to create the backups and restore", func() {
			log.InfoD(fmt.Sprintf("Create a non-admin users to create the backups and restore"))
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for _, role := range roles {
				userName = createUsers(1)[0]
				err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
				log.FailOnError(err, "Failed to add role for user - %s", userName)
				if role == backup.ApplicationOwner {
					appAdminUserName = userName
				} else if role == backup.InfrastructureOwner {
					infraAdminUserName = userName
				} else {
					appUserName = userName
				}
				userNames = append(userNames, userName)
				userUID, err := backup.FetchIDOfUser(userName)
				log.FailOnError(err, "Failed to fetch uid for - %s", userName)
				userIdMap[userName] = userUID
			}
		})

		Step(fmt.Sprintf("Adding Credentials from px-admin user and sharing with required users"), func() {
			log.InfoD(fmt.Sprintf("Adding Credentials from px-admin user and sharing with required users"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, provider := range providers {
				adminCloudCredUID = uuid.New()
				adminCredName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err = CreateCloudCredential(provider, adminCredName, adminCloudCredUID, orgID, adminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				log.Infof("Updating cloud credential ownership for non-admin users")
				if provider != drivers.ProviderNfs {
					err = UpdateCloudCredentialOwnership(adminCredName, adminCloudCredUID, []string{appAdminUserName}, nil, Read, Invalid, adminCtx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying ownership update for cloud credential %s to user %s", adminCredName, []string{appAdminUserName}))
				}
			}
		})

		Step(fmt.Sprintf("Adding backup location from px-admin user and sharing with app users"), func() {
			log.InfoD(fmt.Sprintf("Adding backup location  from px-admin user and sharing with app users"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, provider := range providers {
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationUID = uuid.New()
				err := CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", "", adminCtx)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				log.Infof("Updating backup location ownership for non-admin users")
				err = UpdateBackupLocationOwnership(backupLocationName, backupLocationUID, []string{appUserName}, nil, Read, Invalid, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying ownership update for backup location %s to user %s", backupLocationName, []string{appUserName}))
				backupLocationUserMap[appUserName] = backupLocationName
				backupLocationUidUserMap[appUserName] = backupLocationUID
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Adding backup location for app-admin user and shared cloud cred from px-admin"), func() {
			log.InfoD(fmt.Sprintf("Adding backup location for app-admin user and shared cloud cred from px-admin"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching px-admin ctx")
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationUserMap[appAdminUserName] = backupLocationName
				backupLocationUidUserMap[appAdminUserName] = backupLocationUID
				userBackupLocationMap[appAdminUserName] = map[string]string{backupLocationUID: backupLocationName}
			}
		})

		Step(fmt.Sprintf("Adding cloud credentials and backup location for infra-admin users"), func() {
			log.InfoD(fmt.Sprintf("Adding cloud credentials and backup location for infra-admin users"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching px-admin ctx")
				cloudCredUID := uuid.New()
				credName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, nonAdminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationUserMap[infraAdminUserName] = backupLocationName
				backupLocationUidUserMap[infraAdminUserName] = backupLocationUID
				userCloudCredentialMap[infraAdminUserName] = map[string]string{cloudCredUID: credName}
				userBackupLocationMap[infraAdminUserName] = map[string]string{backupLocationUID: backupLocationName}
			}
		})

		Step(fmt.Sprintf("Create schedule policy from px-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating a schedule policy from px-admin user"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval = 15
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s] for px-admin ", periodicSchedulePolicyInterval, periodicSchedulePolicyName))
			err = UpdateSchedulePolicyOwnership(periodicSchedulePolicyName, periodicSchedulePolicyUid, userNames, nil, Read, Invalid, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for SchedulePolicy- %s", periodicSchedulePolicyName))

		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"))
			for _, nonAdminUserName := range userNames {
				log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
				destClusterUid, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
				clusterInfo := make(map[string]string)
				clusterInfo[SourceClusterName] = srcClusterUid
				clusterInfo[destinationClusterName] = destClusterUid
				clusterUidMap[nonAdminUserName] = clusterInfo
			}
		})

		Step(fmt.Sprintf("Taking manual backup of applications as non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Taking manual backup of applications as non-admin user"))
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					labelSelectors := make(map[string]string, 0)
					backupName := fmt.Sprintf("%s-manual-%s-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					err = CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationUserMap[nonAdminUserName], backupLocationUidUserMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, clusterUidMap[nonAdminUserName][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupName))
					userBackupsMap[nonAdminUserName] = SafeAppend(&mutex, userBackupsMap[nonAdminUserName], backupName).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Taking schedule backup of applications as non-admin user "), func() {
			log.InfoD(fmt.Sprintf("Taking schedule backup of applications as non-admin user"))
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking schedule backup of single namespace as user : %s without-rules", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-single-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationUserMap[nonAdminUserName], backupLocationUidUserMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyName, periodicSchedulePolicyUid)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyName, orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
					userBackupsMap[nonAdminUserName] = SafeAppend(&mutex, userBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step("Sharing of backup of app-user user with app-admin and infra-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of app-user user with app-admin and infra-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(appUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing app-user [%s] backups [%v] with app-admin and infra-admin", appUserName, userBackupsMap[appUserName]))
			for _, appUserBackupName := range userBackupsMap[appUserName] {
				err := ShareBackup(appUserBackupName, nil, []string{appAdminUserName, infraAdminUserName}, 1, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", appUserBackupName, appUserName))
			}
		})

		Step("Sharing of backup of app-admin user with app-user and infra-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of app-admin user with app-user and infra-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing app-admin user [%s] backups [%v] with app-user and infra-admin", appAdminUserName, userBackupsMap[appAdminUserName]))
			for _, appAdminUserBackupName := range userBackupsMap[appAdminUserName] {
				err := ShareBackup(appAdminUserBackupName, nil, []string{appUserName, infraAdminUserName}, 1, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", appAdminUserBackupName, appAdminUserName))
			}
		})

		Step("Sharing of backup of infra-admin user with app-user and app-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of infra-admin user with app-user and app-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing infra-admin user [%s] backups [%v] with app-admin and app-user", infraAdminUserName, userBackupsMap[infraAdminUserName]))
			for _, infraAdminUserBackupName := range userBackupsMap[infraAdminUserName] {
				err := ShareBackup(infraAdminUserBackupName, nil, []string{appAdminUserName, appUserName}, 3, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", infraAdminUserBackupName, infraAdminUserName))
			}
		})

		Step(fmt.Sprintf("Listing and Deletion of shared backup of non-admin users from px-admin user"), func() {
			log.InfoD(fmt.Sprintf("Listing and Deletion of shared backup of non-admin users from px-admin user"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupsOfUsersFromAdmin([]string{userIdMap[nonAdminUserName]}, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupsMap[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin [%v]", nonAdminUserName, userBackupsMap[nonAdminUserName]))
			}
			for _, nonAdminUserName := range userNames {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupsMap[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackup(backupName, backupUID, orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		for _, nonAdminUserName := range userNames {
			userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user "))
			userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
		}
		for _, nonAdminUserName := range userNames {
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			wg.Add(1)
			go func(nonAdminUserName string) {
				defer GinkgoRecover()
				defer wg.Done()
				for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
					log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] ", backupScheduleName, nonAdminUserName))
					backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
					err = DeleteScheduleWithClusterRef(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, nonAdminCtx)
					dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
				}
			}(nonAdminUserName)
		}
		wg.Wait()
		log.Infof("Deleting backup schedule policy")
		err := Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		log.Infof("Cleaning up cluster, backup location and cloud credentials for non admin users")
		for _, nonAdminUserName := range userNames {
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[nonAdminUserName] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[nonAdminUserName], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
			}
			err = backup.DeleteUser(nonAdminUserName)
			log.FailOnError(err, "failed to delete user %s", nonAdminUserName)
		}
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching non admin ctx")
		CleanupCloudSettingsAndClusters(backupLocationMap, adminCredName, adminCloudCredUID, ctx)
	})
})
