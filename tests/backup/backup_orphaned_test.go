package tests

import (
	"fmt"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// 1537-T2
// DeleteObjectsByMultipleUsersFromNewAdmin delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin
var _ = Describe("{DeleteObjectsByMultipleUsersFromNewAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87567

	var (
		scheduledAppContexts       = make([]*scheduler.Context, 0)
		appNamespaces              = make([]string, 0)
		infraAdminUsers            = make([]string, 0)
		providers                  = getProviders()
		userCloudCredentialMap     = make(map[string]map[string]string)
		userBackupLocationMap      = make(map[string]map[string]string)
		userClusterMap             = make(map[string]map[string]string)
		userSchedulePolicyInterval = int64(15)
		userSchedulePolicyMap      = make(map[string]map[string]string)
		userBackupMap              = make(map[string]map[string]string)
		userScheduleNameMap        = make(map[string]string)
		userRestoreMap             = make(map[string]map[string]string)
		numberOfUsers              = 2
		numberOfBackups            = 1
		newAdmin                   string
		adminGroup                                     = "px-admin-group"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteObjectsByMultipleUsersFromNewAdmin", "Delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin", nil, 87567)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups, backup schedules, restore and cluster objects created by multiple user from the new admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
			for _, user := range createUsers(numberOfUsers) {
				err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
				log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
				infraAdminUsers = append(infraAdminUsers, user)
			}
		})
		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, provider := range providers {
					userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
					userCloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
					userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
					userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
					userBackupLocationUID := uuid.New()
					err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
					userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
				}
			})
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userBackupMap[user] = make(map[string]string)
				createBackup := func(backupName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
					for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
						err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
						break
					}
					mu.Lock()
					defer mu.Unlock()
					userBackupMap[user][backupName] = namespace
				}
				for _, namespace := range appNamespaces {
					for i := 0; i < numberOfBackups; i++ {
						backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
						wg.Add(1)
						go createBackup(backupName, namespace)
					}
				}
				wg.Wait()
				log.Infof("The list of user backups taken are: %v", userBackupMap)
			})
			Step(fmt.Sprintf("Create schedule policy from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating schedule policy from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userSchedulePolicyName := fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
				userSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, userSchedulePolicyInterval, 5)
				userSchedulePolicyCreateRequest := &api.SchedulePolicyCreateRequest{
					CreateMetadata: &api.CreateMetadata{
						Name:  userSchedulePolicyName,
						OrgId: orgID,
					},
					SchedulePolicy: userSchedulePolicyInfo,
				}
				_, err = Inst().Backup.CreateSchedulePolicy(nonAdminCtx, userSchedulePolicyCreateRequest)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation schedule policy %s", userSchedulePolicyName))
				userSchedulePolicyUID, err := Inst().Backup.GetSchedulePolicyUid(orgID, nonAdminCtx, userSchedulePolicyName)
				log.FailOnError(err, "failed to fetch schedule policy uid %s of user %s", userSchedulePolicyName, user)
				userSchedulePolicyMap[user] = map[string]string{userSchedulePolicyUID: userSchedulePolicyName}
			})
			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", time.Now().Unix())
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						_, err = CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContexts, make(map[string]string), orgID, "", "", "", "", schedulePolicyName, schedulePolicyUID)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", schedulePolicyName))
						break
					}
					break
				}
				userScheduleNameMap[user] = userScheduleName
			})
		}
		err := TaskHandler(infraAdminUsers, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")
		for _, user := range infraAdminUsers {
			Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userRestoreMap[user] = make(map[string]string, 0)
				createRestore := func(backupName string, restoreName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
					namespaceMapping := map[string]string{namespace: customNamespace}
					err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
					mu.Lock()
					defer mu.Unlock()
					userRestoreMap[user][restoreUid] = restoreName
				}
				for backupName, namespace := range userBackupMap[user] {
					wg.Add(1)
					restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
					go createRestore(backupName, restoreName, namespace)
				}
				wg.Wait()
				log.Infof("The list of user restores taken are: %v", userRestoreMap)
			})
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the admin", userOwnerID)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
		}
		Step(fmt.Sprintf("Add new user to %s group", adminGroup), func() {
			log.InfoD(fmt.Sprintf("Adding new user to %s group", adminGroup))
			for _, user := range createUsers(1) {
				err := backup.AddGroupToUser(user, adminGroup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("failed to add user %s to the group %s", user, adminGroup))
				newAdmin = user
			}
		})
		newAdminCtx, err := backup.GetNonAdminCtx(newAdmin, commonPassword)
		log.FailOnError(err, "Fetching new admin %s ctx", newAdmin)
		cleanupUserObjectsFromAdmin := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Verify backups of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Delete user %s schedule backups, backup schedule and schedule policy from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s schedule backups, backup schedule and schedule policy from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				allScheduleBackupNames, err := Inst().Backup.GetAllScheduleBackupNames(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to get all schedule backup names with schedule name %s of the user %s", userScheduleNameMap[user], user)
				for i := len(allScheduleBackupNames) - 1; i >= 0; i-- {
					backupName := allScheduleBackupNames[i]
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete schedule backup %s of the user %s", backupName, user)
				}
				scheduleUid, err := Inst().Backup.GetBackupScheduleUID(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to fetch backup schedule %s uid of the user %s", userScheduleNameMap[user], user)
				err = DeleteScheduleWithUID(userScheduleNameMap[user], scheduleUid, orgID, newAdminCtx)
				log.FailOnError(err, "failed to delete schedule %s of the user %s", userScheduleNameMap[user], user)
			})
			Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
				for backupName := range userBackupMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(newAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user][SourceClusterName], orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
				}
			})
			Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
				for restoreUid, restoreName := range userRestoreMap[user] {
					err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
				}
			})
			Step(fmt.Sprintf("Wait for the backups and backup schedule to be deleted"), func() {
				log.InfoD("Waiting for the backups and backup schedule to be deleted")
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				clusterInspectReq := &api.ClusterInspectRequest{
					OrgId:          orgID,
					Name:           SourceClusterName,
					Uid:            userClusterMap[user][SourceClusterName],
					IncludeSecrets: true,
				}
				clusterResp, err := Inst().Backup.InspectCluster(nonAdminCtx, clusterInspectReq)
				log.FailOnError(err, "failed to inspect cluster %s", SourceClusterName)
				var wg sync.WaitGroup
				namespace := "*"
				wg.Add(1)
				go func() {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupScheduleDeletion(
						nonAdminCtx,
						userScheduleNameMap[user],
						namespace,
						orgID,
						clusterResp.GetCluster(),
						backupLocationDeleteTimeout,
						backupLocationDeleteRetryTime,
					)
					log.FailOnError(err, "failed while waiting for backup schedule %s to be deleted for the user %s", userScheduleNameMap[user], user)
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						schedulePolicyDeleteRequest := &api.SchedulePolicyDeleteRequest{
							Name:  schedulePolicyName,
							Uid:   schedulePolicyUID,
							OrgId: orgID,
						}
						_, err = Inst().Backup.DeleteSchedulePolicy(newAdminCtx, schedulePolicyDeleteRequest)
						log.FailOnError(err, "failed to delete schedule policy %s of the user %s", schedulePolicyName, user)
						break
					}
				}()
				for backupName := range userBackupMap[user] {
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						err = Inst().Backup.WaitForBackupDeletion(nonAdminCtx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
						log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
					}(backupName)
				}
				wg.Wait()
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the admin", user))
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, newAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
				}
			})
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjectsFromAdmin, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err := TaskHandler(infraAdminUsers, cleanupUserObjects, Sequential)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})
