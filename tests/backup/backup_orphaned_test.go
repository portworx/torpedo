package tests

import (
	"context"
	"fmt"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// DeleteSameNameObjectsByMultipleUsersFromAdmin delete backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin
var _ = Describe("{DeleteSameNameObjectsByMultipleUsersFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87563

	var (
		scheduledAppContexts                           = make([]*scheduler.Context, 0)
		appNamespaces                                  = make([]string, 0)
		infraAdminUsers                                = make([]string, 0)
		providers                                      = getProviders()
		userCloudCredentialMap                         = make(map[string]map[string]string)
		userBackupLocationMap                          = make(map[string]map[string]string)
		userClusterMap                                 = make(map[string]map[string]string)
		userSchedulePolicyInterval                     = int64(15)
		userSchedulePolicyMap                          = make(map[string]map[string]string)
		userBackupMap                                  = make(map[string]map[string]string)
		userScheduleNameMap                            = make(map[string]string)
		userRestoreMap                                 = make(map[string]map[string]string)
		numberOfUsers                                  = 3
		numberOfBackups                                = 1
		randomSuffix                                   = RandomString(4)
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteSameNameObjectsByMultipleUsersFromAdmin", "Delete backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin", nil, 87563)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin", func() {
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
			for _, user := range createUsers(numberOfUsers) {
				err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
				log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
				infraAdminUsers = append(infraAdminUsers, user)
			}
		})
		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, provider := range providers {
					userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", randomSuffix)
					userCloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
					userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
					userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", randomSuffix)
					userBackupLocationUID := uuid.New()
					err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
					userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
				}
			})
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userBackupMap[user] = make(map[string]string)
				createBackup := func(backupName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
					for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
						err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
						break
					}
					mu.Lock()
					defer mu.Unlock()
					userBackupMap[user][backupName] = namespace
				}
				for _, namespace := range appNamespaces {
					for i := 0; i < numberOfBackups; i++ {
						backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, randomSuffix)
						wg.Add(1)
						go createBackup(backupName, namespace)
					}
				}
				wg.Wait()
				log.Infof("The list of user backups taken are: %v", userBackupMap)
			})
			Step(fmt.Sprintf("Create schedule policy from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating schedule policy from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userSchedulePolicyName := fmt.Sprintf("%s-%v", "periodic", randomSuffix)
				userSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, userSchedulePolicyInterval, 5)
				userSchedulePolicyCreateRequest := &api.SchedulePolicyCreateRequest{
					CreateMetadata: &api.CreateMetadata{
						Name:  userSchedulePolicyName,
						OrgId: orgID,
					},
					SchedulePolicy: userSchedulePolicyInfo,
				}
				_, err = Inst().Backup.CreateSchedulePolicy(nonAdminCtx, userSchedulePolicyCreateRequest)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation schedule policy %s", userSchedulePolicyName))
				userSchedulePolicyUID, err := Inst().Backup.GetSchedulePolicyUid(orgID, nonAdminCtx, userSchedulePolicyName)
				log.FailOnError(err, "failed to fetch schedule policy uid %s of user %s", userSchedulePolicyName, user)
				userSchedulePolicyMap[user] = map[string]string{userSchedulePolicyUID: userSchedulePolicyName}
			})
			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", randomSuffix)
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						_, err = CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContexts, make(map[string]string), orgID, "", "", "", "", schedulePolicyName, schedulePolicyUID)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", schedulePolicyName))
						break
					}
					break
				}
				userScheduleNameMap[user] = userScheduleName
			})
		}
		err = TaskHandler(infraAdminUsers, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")
		for _, user := range infraAdminUsers {
			Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userRestoreMap[user] = make(map[string]string, 0)
				createRestore := func(backupName string, restoreName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					customNamespace := "custom-" + namespace + randomSuffix
					namespaceMapping := map[string]string{namespace: customNamespace}
					err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
					mu.Lock()
					defer mu.Unlock()
					userRestoreMap[user][restoreUid] = restoreName
				}
				for backupName, namespace := range userBackupMap[user] {
					wg.Add(1)
					restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
					go createRestore(backupName, restoreName, namespace)
				}
				wg.Wait()
				log.Infof("The list of user restores taken are: %v", userRestoreMap)
			})
			Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the admin", userOwnerID)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
		}
		cleanupUserObjectsFromAdmin := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Delete user %s schedule backups, backup schedule and schedule policy from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s schedule backups, backup schedule and schedule policy from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				allScheduleBackupNames, err := Inst().Backup.GetAllScheduleBackupNames(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to get all schedule backup names with schedule name %s of the user %s", userScheduleNameMap[user], user)
				for i := len(allScheduleBackupNames) - 1; i >= 0; i-- {
					backupName := allScheduleBackupNames[i]
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, orgID, ctx)
					log.FailOnError(err, "failed to delete schedule backup %s of the user %s", backupName, user)
				}
				scheduleUid, err := Inst().Backup.GetBackupScheduleUID(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to fetch backup schedule %s uid of the user %s", userScheduleNameMap[user], user)
				err = DeleteScheduleWithUID(userScheduleNameMap[user], scheduleUid, orgID, ctx)
				log.FailOnError(err, "failed to delete schedule %s of the user %s", userScheduleNameMap[user], user)
			})
			Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for backupName := range userBackupMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user][SourceClusterName], orgID, ctx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
				}
			})
			Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
				for restoreUid, restoreName := range userRestoreMap[user] {
					err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, ctx)
					log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
				}
			})
			Step(fmt.Sprintf("Wait for the backups and backup schedule to be deleted"), func() {
				log.InfoD("Waiting for the backups and backup schedule to be deleted")
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				clusterInspectReq := &api.ClusterInspectRequest{
					OrgId:          orgID,
					Name:           SourceClusterName,
					Uid:            userClusterMap[user][SourceClusterName],
					IncludeSecrets: true,
				}
				clusterResp, err := Inst().Backup.InspectCluster(nonAdminCtx, clusterInspectReq)
				log.FailOnError(err, "failed to inspect cluster %s", SourceClusterName)
				var wg sync.WaitGroup
				namespace := "*"
				wg.Add(1)
				go func() {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupScheduleDeletion(
						nonAdminCtx,
						userScheduleNameMap[user],
						namespace,
						orgID,
						clusterResp.GetCluster(),
						backupLocationDeleteTimeout,
						backupLocationDeleteRetryTime,
					)
					log.FailOnError(err, "failed while waiting for backup schedule %s to be deleted for the user %s", userScheduleNameMap[user], user)
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						schedulePolicyDeleteRequest := &api.SchedulePolicyDeleteRequest{
							Name:  schedulePolicyName,
							Uid:   schedulePolicyUID,
							OrgId: orgID,
						}
						_, err = Inst().Backup.DeleteSchedulePolicy(ctx, schedulePolicyDeleteRequest)
						log.FailOnError(err, "failed to delete schedule policy %s of the user %s", schedulePolicyName, user)
						break
					}
				}()
				for backupName := range userBackupMap[user] {
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						err = Inst().Backup.WaitForBackupDeletion(nonAdminCtx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
						log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
					}(backupName)
				}
				wg.Wait()
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the admin", user))
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, ctx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
				}
			})
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjectsFromAdmin, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err := TaskHandler(infraAdminUsers, cleanupUserObjects, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin deletes user backups and restores of the deleted and inactive cluster from the admin
var _ = Describe("{DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87569

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		infraAdminUsers                            = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		userRestoreMap                             = make(map[string]map[string]string)
		numberOfUsers                              = 1
		numberOfBackups                            = 1
		invalidKubeconfig                          = "\"\""
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		deleteUserClusters                         = false
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin", "Delete user backups and restores of the deleted and inactive cluster from the admin", nil, 87569)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes user backups and restores of the deleted and inactive cluster from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		for i := 0; i < 2; i++ {
			Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
				log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
				for _, user := range createUsers(numberOfUsers) {
					err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
					log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
					infraAdminUsers = append(infraAdminUsers, user)
				}
			})
			createObjectsFromUser := func(user string) {
				Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					for _, provider := range providers {
						userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
						userCloudCredentialUID := uuid.New()
						err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
						log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
						userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
						userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
						userBackupLocationUID := uuid.New()
						err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
						log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
						userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
					}
				})
				Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
					clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
					dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
					userClusterMap[user] = make(map[string]string)
					for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
						userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
						userClusterMap[user][clusterName] = userClusterUID
					}
				})
				Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userBackupMap[user] = make(map[string]string)
					createBackup := func(backupName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
						for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
							err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
							break
						}
						mu.Lock()
						defer mu.Unlock()
						userBackupMap[user][backupName] = namespace
					}
					for _, namespace := range appNamespaces {
						for i := 0; i < numberOfBackups; i++ {
							backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
							wg.Add(1)
							go createBackup(backupName, namespace)
						}
					}
					wg.Wait()
					log.Infof("The list of user backups taken are: %v", userBackupMap)
				})
				Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
					for backupName := range userBackupMap[user] {
						if !IsPresent(backupNamesByOwnerID, backupName) {
							err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
			}
			err := TaskHandler([]string{infraAdminUsers[i]}, createObjectsFromUser, Parallel)
			log.FailOnError(err, "failed to create objects from user")
			for _, user := range []string{infraAdminUsers[i]} {
				Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userRestoreMap[user] = make(map[string]string, 0)
					createRestore := func(backupName string, restoreName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
						namespaceMapping := map[string]string{namespace: customNamespace}
						err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
						restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
						log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
						mu.Lock()
						defer mu.Unlock()
						userRestoreMap[user][restoreUid] = restoreName
					}
					for backupName, namespace := range userBackupMap[user] {
						wg.Add(1)
						restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
						go createRestore(backupName, restoreName, namespace)
					}
					wg.Wait()
					log.Infof("The list of user restores taken are: %v", userRestoreMap)
				})
				Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
					for _, restoreName := range userRestoreMap[user] {
						if !IsPresent(restoreNamesByOwnerID, restoreName) {
							err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
				if i == 0 {
					Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
						log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, nonAdminCtx, false)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
						}
					})
				} else {
					deleteUserClusters = true
					Step(fmt.Sprintf("Make source and destination cluster inactive from the user %s", user), func() {
						log.InfoD(fmt.Sprintf("Making source and destination cluster inactive from the user %s", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							clusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
							log.FailOnError(err, "failed to fetch cluster %s uid", clusterName)
							clusterUpdateRequest := &api.ClusterUpdateRequest{
								CreateMetadata: &api.CreateMetadata{
									Name:  clusterName,
									Uid:   clusterUID,
									OrgId: orgID,
								},
								Kubeconfig: invalidKubeconfig,
							}
							_, err = Inst().Backup.UpdateCluster(nonAdminCtx, clusterUpdateRequest)
							if err != nil {
								clusterStatus, statusError := Inst().Backup.GetClusterStatus(orgID, clusterName, nonAdminCtx)
								log.FailOnError(statusError, "failed to get cluster status %s", clusterName)
								if clusterStatus != api.ClusterInfo_StatusInfo_Failed {
									log.FailOnError(err, "failed to make cluster %s inactive. Expected status %v but got %v", clusterName, api.ClusterInfo_StatusInfo_Failed, clusterStatus)
								}
							} else {
								err = fmt.Errorf("failed to make cluster %s inactive. Expected error not be nil", clusterName)
								log.FailOnError(fmt.Errorf(""), err.Error())
							}
						}
					})
				}
			}
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			cleanupUserObjectsFromAdmin := func(user string) {
				defer GinkgoRecover()
				Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
					for backupName := range userBackupMap[user] {
						backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
						log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
						_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user][SourceClusterName], orgID, ctx)
						log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					}
				})
				Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
					for restoreUid, restoreName := range userRestoreMap[user] {
						err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, ctx)
						log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
					}
				})
			}
			err = TaskHandler([]string{infraAdminUsers[i]}, cleanupUserObjectsFromAdmin, Parallel)
			log.FailOnError(err, "failed to cleanup user objects from admin")
			if deleteUserClusters {
				for _, user := range []string{infraAdminUsers[i]} {
					Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
						log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, nonAdminCtx, false)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
						}
					})
				}
			}
		}
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err := TaskHandler(infraAdminUsers, cleanupUserObjects, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteObjectsByMultipleUsersFromNewAdmin delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin
var _ = Describe("{DeleteObjectsByMultipleUsersFromNewAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87567

	var (
		scheduledAppContexts       = make([]*scheduler.Context, 0)
		appNamespaces              = make([]string, 0)
		infraAdminUsers            = make([]string, 0)
		providers                  = getProviders()
		userCloudCredentialMap     = make(map[string]map[string]string)
		userBackupLocationMap      = make(map[string]map[string]string)
		userClusterMap             = make(map[string]map[string]string)
		userSchedulePolicyInterval = int64(15)
		userSchedulePolicyMap      = make(map[string]map[string]string)
		userBackupMap              = make(map[string]map[string]string)
		userScheduleNameMap        = make(map[string]string)
		userRestoreMap             = make(map[string]map[string]string)
		numberOfUsers              = 2
		numberOfBackups            = 1
		newAdmin                   string
		adminGroup                                     = "px-admin-group"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteObjectsByMultipleUsersFromNewAdmin", "Delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin", nil, 87567)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups, backup schedules, restore and cluster objects created by multiple user from the new admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
			for _, user := range createUsers(numberOfUsers) {
				err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
				log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
				infraAdminUsers = append(infraAdminUsers, user)
			}
		})
		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, provider := range providers {
					userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
					userCloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
					userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
					userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
					userBackupLocationUID := uuid.New()
					err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
					userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
				}
			})
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userBackupMap[user] = make(map[string]string)
				createBackup := func(backupName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
					for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
						err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
						break
					}
					mu.Lock()
					defer mu.Unlock()
					userBackupMap[user][backupName] = namespace
				}
				for _, namespace := range appNamespaces {
					for i := 0; i < numberOfBackups; i++ {
						backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
						wg.Add(1)
						go createBackup(backupName, namespace)
					}
				}
				wg.Wait()
				log.Infof("The list of user backups taken are: %v", userBackupMap)
			})
			Step(fmt.Sprintf("Create schedule policy from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating schedule policy from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userSchedulePolicyName := fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
				userSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, userSchedulePolicyInterval, 5)
				userSchedulePolicyCreateRequest := &api.SchedulePolicyCreateRequest{
					CreateMetadata: &api.CreateMetadata{
						Name:  userSchedulePolicyName,
						OrgId: orgID,
					},
					SchedulePolicy: userSchedulePolicyInfo,
				}
				_, err = Inst().Backup.CreateSchedulePolicy(nonAdminCtx, userSchedulePolicyCreateRequest)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation schedule policy %s", userSchedulePolicyName))
				userSchedulePolicyUID, err := Inst().Backup.GetSchedulePolicyUid(orgID, nonAdminCtx, userSchedulePolicyName)
				log.FailOnError(err, "failed to fetch schedule policy uid %s of user %s", userSchedulePolicyName, user)
				userSchedulePolicyMap[user] = map[string]string{userSchedulePolicyUID: userSchedulePolicyName}
			})
			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", time.Now().Unix())
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						_, err = CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContexts, make(map[string]string), orgID, "", "", "", "", schedulePolicyName, schedulePolicyUID)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", schedulePolicyName))
						break
					}
					break
				}
				userScheduleNameMap[user] = userScheduleName
			})
		}
		err := TaskHandler(infraAdminUsers, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")
		for _, user := range infraAdminUsers {
			Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userRestoreMap[user] = make(map[string]string, 0)
				createRestore := func(backupName string, restoreName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
					namespaceMapping := map[string]string{namespace: customNamespace}
					err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
					mu.Lock()
					defer mu.Unlock()
					userRestoreMap[user][restoreUid] = restoreName
				}
				for backupName, namespace := range userBackupMap[user] {
					wg.Add(1)
					restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
					go createRestore(backupName, restoreName, namespace)
				}
				wg.Wait()
				log.Infof("The list of user restores taken are: %v", userRestoreMap)
			})
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the admin", userOwnerID)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
		}
		Step(fmt.Sprintf("Add new user to %s group", adminGroup), func() {
			log.InfoD(fmt.Sprintf("Adding new user to %s group", adminGroup))
			for _, user := range createUsers(1) {
				err := backup.AddGroupToUser(user, adminGroup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying addition of user %s to the group %s", user, adminGroup))
				newAdmin = user
			}
		})
		newAdminCtx, err := backup.GetNonAdminCtx(newAdmin, commonPassword)
		log.FailOnError(err, "Fetching new admin %s ctx", newAdmin)
		cleanupUserObjectsFromAdmin := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Verify backups of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Delete user %s schedule backups, backup schedule and schedule policy from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s schedule backups, backup schedule and schedule policy from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				allScheduleBackupNames, err := Inst().Backup.GetAllScheduleBackupNames(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to get all schedule backup names with schedule name %s of the user %s", userScheduleNameMap[user], user)
				for i := len(allScheduleBackupNames) - 1; i >= 0; i-- {
					backupName := allScheduleBackupNames[i]
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete schedule backup %s of the user %s", backupName, user)
				}
				scheduleUid, err := Inst().Backup.GetBackupScheduleUID(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to fetch backup schedule %s uid of the user %s", userScheduleNameMap[user], user)
				err = DeleteScheduleWithUID(userScheduleNameMap[user], scheduleUid, orgID, newAdminCtx)
				log.FailOnError(err, "failed to delete schedule %s of the user %s", userScheduleNameMap[user], user)
			})
			Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
				for backupName := range userBackupMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(newAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user][SourceClusterName], orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
				}
			})
			Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
				for restoreUid, restoreName := range userRestoreMap[user] {
					err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
				}
			})
			Step(fmt.Sprintf("Wait for the backups and backup schedule to be deleted"), func() {
				log.InfoD("Waiting for the backups and backup schedule to be deleted")
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				clusterInspectReq := &api.ClusterInspectRequest{
					OrgId:          orgID,
					Name:           SourceClusterName,
					Uid:            userClusterMap[user][SourceClusterName],
					IncludeSecrets: true,
				}
				clusterResp, err := Inst().Backup.InspectCluster(nonAdminCtx, clusterInspectReq)
				log.FailOnError(err, "failed to inspect cluster %s", SourceClusterName)
				var wg sync.WaitGroup
				namespace := "*"
				wg.Add(1)
				go func() {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupScheduleDeletion(
						nonAdminCtx,
						userScheduleNameMap[user],
						namespace,
						orgID,
						clusterResp.GetCluster(),
						backupLocationDeleteTimeout,
						backupLocationDeleteRetryTime,
					)
					log.FailOnError(err, "failed while waiting for backup schedule %s to be deleted for the user %s", userScheduleNameMap[user], user)
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						schedulePolicyDeleteRequest := &api.SchedulePolicyDeleteRequest{
							Name:  schedulePolicyName,
							Uid:   schedulePolicyUID,
							OrgId: orgID,
						}
						_, err = Inst().Backup.DeleteSchedulePolicy(newAdminCtx, schedulePolicyDeleteRequest)
						log.FailOnError(err, "failed to delete schedule policy %s of the user %s", schedulePolicyName, user)
						break
					}
				}()
				for backupName := range userBackupMap[user] {
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						err = Inst().Backup.WaitForBackupDeletion(nonAdminCtx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
						log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
					}(backupName)
				}
				wg.Wait()
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the admin", user))
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, newAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
				}
			})
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjectsFromAdmin, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err := TaskHandler(infraAdminUsers, cleanupUserObjects, Sequential)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin deletes failed and in-progress backups and restores of user from the admin
var _ = Describe("{DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87564

	var (
		scheduledAppContexts                           = make([]*scheduler.Context, 0)
		appNamespaces                                  = make([]string, 0)
		userCloudCredentialMap                         = make(map[string]string)
		userBackupLocationMap                          = make(map[string]string)
		providers                                      = getProviders()
		userInProgressBackupNames                      = make([]string, 0)
		userFailedBackupNames                          = make([]string, 0)
		userSuccessfulBackupMap                        = make(map[string]string)
		userInProgressRestoreNames                     = make([]string, 0)
		userFailedRestoreNames                         = make([]string, 0)
		deletedUserRestoreMap                          = make(map[string]bool)
		numberOfBackups                                = 1
		invalidNamespace                               = "-"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
		userSourceClusterUID       string
		infraAdminUser             string
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin", "Delete failed and in-progress backups and restores of user from the admin side", nil, 87564)
		log.InfoD("Scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Delete failed and in-progress backups and restores of user from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create user with %s role", infraAdminRole), func() {
			infraAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(infraAdminUser, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, infraAdminUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
			log.Infof("username %s common password %s", infraAdminUser, commonPassword)

		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[userCloudCredentialUID] = userCloudCredentialName
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[userBackupLocationUID] = userBackupLocationName
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", infraAdminUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userSourceClusterUID, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})
		Step(fmt.Sprintf("Take in progress backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{namespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
					userInProgressBackupNames = append(userInProgressBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of in progress user backups taken are: %v", userInProgressBackupNames)
		})
		Step(fmt.Sprintf("Verify in progress backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userInProgressBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("in progress backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress backups taken by user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			backupEnumerateRequest := &api.BackupEnumerateRequest{
				OrgId: orgID,
				EnumerateOptions: &api.EnumerateOptions{
					Owners: []string{userOwnerID},
				},
			}
			deletedUserBackupMap := make(map[string]bool)
			deleteInProgressBackup := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateBackup(ctx, backupEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingBackups := false
				for _, backup := range resp.GetBackups() {
					if IsPresent(userInProgressBackupNames, backup.GetName()) {
						actual := backup.GetStatus().GetStatus()
						switch actual {
						case api.BackupInfo_StatusInfo_InProgress:
							backupName := backup.GetName()
							if _, exists := deletedUserBackupMap[backupName]; exists {
								continue
							}
							wg.Add(1)
							go func(backup *api.BackupObject, ctx context.Context) {
								defer wg.Done()
								_, err := DeleteBackup(backup.GetName(), backup.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(backup, ctx)
							deletedUserBackupMap[backupName] = true
						case api.BackupInfo_StatusInfo_Pending:
							pendingBackups = true
						}
					} else {
						log.Warnf("backup %s with uid %s may not have been created by this testcase", backup.GetName(), backup.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingBackups {
						return "", true, fmt.Errorf("there are pending backups")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressBackup, maxWaitPeriodForBackupJobCancellation*time.Minute, backupJobCancellationRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress backups"))
			dash.VerifyFatal(len(deletedUserBackupMap) > 0, true, "Verifying if there is at least one in progress backup")
		})
		Step(fmt.Sprintf("Take failed backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{invalidNamespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					if err != nil {
						backupUID, UIDError := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
						log.FailOnError(UIDError, "failed to get backup %s uid", backupName)
						backupInspectRequest := &api.BackupInspectRequest{
							Name:  backupName,
							OrgId: orgID,
							Uid:   backupUID,
						}
						resp, inspectError := Inst().Backup.InspectBackup(nonAdminCtx, backupInspectRequest)
						log.FailOnError(inspectError, "failed to inspect backup %s", backupName)
						if resp.GetBackup().GetStatus().GetStatus() != api.BackupInfo_StatusInfo_Failed {
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
						}
					}
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
					userFailedBackupNames = append(userFailedBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of failed user backups taken are: %v", userFailedBackupNames)
		})
		Step(fmt.Sprintf("Verify failed backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userFailedBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("failed backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed backups taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range userFailedBackupNames {
				backupUID, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "failed to fetch backup %s uid", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				log.FailOnError(err, "failed to delete backup %s uid", backupName)
			}
		})
		Step(fmt.Sprintf("Take successful backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking successful backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userSourceClusterUID, "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userSuccessfulBackupMap[backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of successful user backups taken are: %v", userSuccessfulBackupMap)
		})
		Step(fmt.Sprintf("Verify successful backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying successful backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userSuccessfulBackupMap {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("successful backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Take in progress restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: fmt.Sprintf("r-%s-%v", namespace, time.Now().Unix())}
				_, err = CreateRestoreWithoutCheck(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
				mu.Lock()
				defer mu.Unlock()
				userInProgressRestoreNames = append(userInProgressRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of in progress user restores taken are: %v", userInProgressRestoreNames)
		})
		Step(fmt.Sprintf("Verify in progress restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userInProgressRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("in progress restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreEnumerateRequest := &api.RestoreEnumerateRequest{
				OrgId: orgID,
			}
			deleteInProgressRestore := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateRestore(ctx, restoreEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingRestores := false
				for _, restore := range resp.GetRestores() {
					if IsPresent(userInProgressRestoreNames, restore.GetName()) {
						actual := restore.GetStatus().GetStatus()
						switch actual {
						case api.RestoreInfo_StatusInfo_InProgress:
							restoreName := restore.GetName()
							if _, exists := deletedUserRestoreMap[restoreName]; exists {
								continue
							}
							wg.Add(1)
							go func(restore *api.RestoreObject, ctx context.Context) {
								defer wg.Done()
								err := DeleteRestoreWithUID(restore.GetName(), restore.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(restore, ctx)
							deletedUserRestoreMap[restoreName] = true
						case api.RestoreInfo_StatusInfo_Pending:
							pendingRestores = true
						}
					} else {
						log.Warnf("restore %s with uid %s may not have been created by this testcase", restore.GetName(), restore.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingRestores {
						return "", true, fmt.Errorf("there are pending restores")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressRestore, maxWaitPeriodForRestoreJobCancellation*time.Minute, restoreJobProgressRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress restores"))
			dash.VerifyFatal(len(deletedUserRestoreMap) > 0, true, "Verifying if there is at least one in progress restores")
		})
		Step(fmt.Sprintf("Take failed restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: invalidNamespace}
				backupUID, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
				log.FailOnError(err, "failed to get backup %s uid", backupName)
				err = CreateRestoreWithUID(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx, make(map[string]string), backupUID)
				if err != nil {
					restoreUID, UIDError := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(UIDError, "failed to get restore %s uid", restoreName)
					restoreInspectRequest := &api.RestoreInspectRequest{
						Name:  restoreName,
						OrgId: orgID,
						Uid:   restoreUID,
					}
					resp, inspectError := Inst().Backup.InspectRestore(nonAdminCtx, restoreInspectRequest)
					log.FailOnError(inspectError, "failed to inspect restore %s", backupName)
					if resp.GetRestore().GetStatus().GetStatus() != api.RestoreInfo_StatusInfo_Failed {
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					}
				}
				mu.Lock()
				defer mu.Unlock()
				userFailedRestoreNames = append(userFailedRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of failed user restores taken are: %v", userFailedRestoreNames)
		})
		Step(fmt.Sprintf("Verify failed restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userFailedRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("failed restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, restoreName := range userFailedRestoreNames {
				restoreUID, err := Inst().Backup.GetRestoreUID(ctx, restoreName, orgID)
				log.FailOnError(err, "failed to fetch restore %s uid", restoreName)
				err = DeleteRestoreWithUID(restoreName, restoreUID, orgID, ctx)
				log.FailOnError(err, "failed to delete restore %s uid", restoreName)
			}
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
		log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap {
			CleanupCloudSettingsAndClusters(userBackupLocationMap, cloudCredentialName, cloudCredentialUID, nonAdminCtx)
			break
		}
		err = backup.DeleteUser(infraAdminUser)
		log.FailOnError(err, "failed to delete user %s", infraAdminUser)
	})
})

// DeleteSharedBackupOfUserFromAdmin deletes backups shared by the user from the admin
var _ = Describe("{DeleteSharedBackupOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87562

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		numberOfBackups                            = 1
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		user1                  string
		user2                  string
		user3                  string
	)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteSharedBackupOfUserFromAdmin", "Delete backups shared by the user from the admin", nil, 87562)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups shared by the user from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", 3, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", 3, infraAdminRole))
			user1 = createUsers(1)[0]
			err := backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user1))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user1)
			user2 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user2))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user2)
			user3 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user3))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user3)
		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[user1] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[user1] = map[string]string{userBackupLocationUID: userBackupLocationName}
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", user1)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[user1] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[user1][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			userBackupMap[user1] = make(map[string]string)
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user1] {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user1][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userBackupMap[user1][backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, time.Now().Unix())
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of user backups taken are: %v", userBackupMap)
		})
		Step(fmt.Sprintf("Share user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for backupName := range userBackupMap[user1] {
				err := ShareBackup(backupName, nil, []string{user2}, ViewOnlyAccess, nonAdminCtx)
				log.FailOnError(err, "failed to share user %s backup %s [backup-share] with user %s with ViewOnlyAccess", user1, backupName, user2)
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin2Ctx, err := backup.GetNonAdminCtx(user2, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin2Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user2)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Share user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = ClusterUpdateBackupShare(SourceClusterName, nil, []string{user3}, ViewOnlyAccess, true, nonAdminCtx)
			log.FailOnError(err, "failed to share user %s backups %s [cluster-share] with user %s with ViewOnlyAccess", user1, userBackupMap[user1], user3)
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin3Ctx, err := backup.GetNonAdminCtx(user3, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin3Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user3)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the admin", user1), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete the owner [%s] of the backups", user1), func() {
			log.InfoD(fmt.Sprintf("Deleting the owner [%s] of the backups", user1))
			err := backup.DeleteUser(user1)
			log.FailOnError(err, "failed to delete user %s", user1)
		})
		Step(fmt.Sprintf("Delete user %s backups from the admin", user2), func() {
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user2))
			for backupName := range userBackupMap[user1] {
				backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user2)
				_, err = DeleteBackupWithClusterUID(backupName, backupUid, userClusterMap[user2][SourceClusterName], orgID, ctx)
				log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user2)
			}
		})
		Step(fmt.Sprintf("Wait for the backups to be deleted"), func() {
			log.InfoD("Waiting for the backups to be deleted")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			var wg sync.WaitGroup
			for backupName := range userBackupMap[user1] {
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupDeletion(ctx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
					log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
				}(backupName)
			}
			wg.Wait()
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user1] {
			CleanupCloudSettingsAndClusters(userBackupLocationMap[user1], cloudCredentialName, cloudCredentialUID, ctx)
			break
		}
		err = backup.DeleteUser(user2)
		log.FailOnError(err, "failed to delete user %s", user2)
		err = backup.DeleteUser(user3)
		log.FailOnError(err, "failed to delete user %s", user3)
	})
})
