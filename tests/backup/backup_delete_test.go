package tests

import (
	"fmt"
	"strings"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// IssueDeleteOfIncrementalBackupsAndRestore Issues delete of incremental backups in between and tries to restore from
// the newest backup.
var _ = Describe("{IssueDeleteOfIncrementalBackupsAndRestore}", func() {
	var (
		credName                 string
		clusterUid               string
		cloudCredUID             string
		fullBackupName           string
		restoreName              string
		backupLocationUID        string
		customBackupLocationName string
		incrementalBackupName    string
		restoreNames             []string
		cloudCredUidList         []string
		namespaceMapping         map[string]string
		appContexts              []*scheduler.Context
		contexts                 []*scheduler.Context
		clusterStatus            api.ClusterInfo_StatusInfo_Status
	)
	labelSelectors := make(map[string]string)
	backupNames := make([]string, 0)
	incrementalBackupNames := make([]string, 0)
	incrementalBackupNames2 := make([]string, 0)
	var bkpNamespaces = make([]string, 0)
	backupLocationMap := make(map[string]string)

	JustBeforeEach(func() {
		StartTorpedoTest("IssueDeleteOfIncrementalBackupsAndRestore",
			"Issue delete of incremental backups and try to restore the newest backup", nil, 58056)
		log.InfoD("Deploy applications")

		contexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts = ScheduleApplications(taskName)
			contexts = append(contexts, appContexts...)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Issue delete of incremental backups and try to restore the newest backup", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(contexts)
		})

		Step("Adding Credentials and Registering Backup Location", func() {
			log.InfoD("Creating cloud credentials and backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err := CreateCloudCredential(provider, CredName, CloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of cloud credential named [%s] for org [%s] with [%s] as provider", CredName, orgID, provider))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				customBackupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				err = CreateBackupLocation(provider, customBackupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", customBackupLocationName))
				backupLocationMap[backupLocationUID] = customBackupLocationName
				log.InfoD("Created Backup Location with name - %s", customBackupLocationName)
			}
		})

		Step("Register source and destination cluster for backup", func() {
			log.InfoD("Registering Source and Destination clusters and verifying the status")
			// Registering for admin user
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateSourceAndDestClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, "Creating source and destination cluster")
			clusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})

		Step("Taking backup of applications", func() {
			log.InfoD("Taking backup of applications")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			// Full backup
			for _, namespace := range bkpNamespaces {
				fullBackupName = fmt.Sprintf("%s-%s-%v", "full-backup", namespace, time.Now().Unix())
				backupNames = append(backupNames, fullBackupName)
				err = CreateBackup(fullBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying full backup [%s] creation", fullBackupName))
			}

			// Incremental backup set 1
			for _, namespace := range bkpNamespaces {
				incrementalBackupName = fmt.Sprintf("%s-%s-%v", "incremental-backup", namespace, time.Now().Unix())
				incrementalBackupNames = append(incrementalBackupNames, incrementalBackupName)
				err = CreateBackup(incrementalBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying incremental backup [%s] creation", incrementalBackupName))
			}

			// Incremental backup set 2
			for _, namespace := range bkpNamespaces {
				incrementalBackupName = fmt.Sprintf("%s-%s-%v", "incremental-backup", namespace, time.Now().Unix())
				incrementalBackupNames2 = append(incrementalBackupNames2, incrementalBackupName)
				err = CreateBackup(incrementalBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying incremental backup [%s] creation", incrementalBackupName))
			}
			log.InfoD("List of backups - %v", backupNames)
			log.InfoD("List of Incremental backups Set 1 - %v", incrementalBackupNames)
			log.InfoD("List of Incremental backups Set 2 - %v", incrementalBackupNames2)
		})

		Step("Check if backups are full backups or not", func() {
			log.InfoD("Check if backups are full backups or not")
			backupDriver := Inst().Backup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, fullbackup := range backupNames {
				bkpUid, err := backupDriver.GetBackupUID(ctx, fullbackup, orgID)
				log.FailOnError(err, "Unable to fetch backup UID - %s", fullbackup)
				bkpInspectReq := &api.BackupInspectRequest{
					Name:  fullbackup,
					OrgId: orgID,
					Uid:   bkpUid,
				}
				bkpInspectResponse, err := backupDriver.InspectBackup(ctx, bkpInspectReq)
				log.FailOnError(err, "Unable to fetch backup - %s", fullbackup)
				for _, vol := range bkpInspectResponse.GetBackup().GetVolumes() {
					backupId := vol.GetBackupId()
					dash.VerifyFatal(strings.Contains(backupId, "incr"), false,
						fmt.Sprintf("Check if the backup %s is full or not", fullbackup))
				}
			}
		})

		Step("Deleting incremental backup", func() {
			log.InfoD("Deleting incremental backups")
			backupDriver := Inst().Backup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range incrementalBackupNames {
				log.Infof("About to delete backup - %s", backupName)
				backupUID, err := backupDriver.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "Failed while trying to get backup UID for - %s", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting backup - [%s]", backupName))
			}
		})
		Step("Check if backups are incremental backups or not", func() {
			log.InfoD("Check if backups are incremental backups or not")
			backupDriver := Inst().Backup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, incrementalBackupName := range incrementalBackupNames2 {
				bkpUid, err := backupDriver.GetBackupUID(ctx, incrementalBackupName, orgID)
				log.FailOnError(err, "Unable to fetch backup UID - %s", incrementalBackupName)
				bkpInspectReq := &api.BackupInspectRequest{
					Name:  incrementalBackupName,
					OrgId: orgID,
					Uid:   bkpUid,
				}
				bkpInspectResponse, err := backupDriver.InspectBackup(ctx, bkpInspectReq)
				log.FailOnError(err, "Unable to fetch backup - %s", incrementalBackupName)
				for _, vol := range bkpInspectResponse.GetBackup().GetVolumes() {
					backupId := vol.GetBackupId()
					dash.VerifyFatal(strings.Contains(backupId, "incr"), true,
						fmt.Sprintf("Check if the backup %s is incremental or not", incrementalBackupName))
				}
			}
		})
		Step("Restoring the backed up namespaces", func() {
			log.InfoD("Restoring the backed up namespaces")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range incrementalBackupNames2 {
				restoreName = fmt.Sprintf("%s-%s", backupName, RandomString(4))
				for strings.Contains(strings.Join(restoreNames, ","), restoreName) {
					restoreName = fmt.Sprintf("%s-%s", backupName, RandomString(4))
				}
				log.InfoD("Restoring %s backup", backupName)
				err = CreateRestore(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, ctx, make(map[string]string))
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating restore [%s]", restoreName))
				restoreNames = append(restoreNames, restoreName)
			}
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(contexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		// Cleaning up applications created
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		ValidateAndDestroy(contexts, opts)

		// Remove all the restores created
		log.Info("Deleting restored namespaces")
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for _, restoreName := range restoreNames {
			err := DeleteRestore(restoreName, orgID, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Restore [%s]", restoreName))
		}

		// Cleaning up px-backup cluster
		ctx, err = backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// DeleteIncrementalBackupsAndRecreateNew Delete Incremental Backups and Recreate
// new ones
var _ = Describe("{DeleteIncrementalBackupsAndRecreateNew}", func() {
	backupNames := make([]string, 0)
	incrementalBackupNames := make([]string, 0)
	incrementalBackupNamesRecreated := make([]string, 0)
	var contexts []*scheduler.Context
	labelSelectors := make(map[string]string)
	var backupLocationUID string
	var cloudCredUID string
	var cloudCredUidList []string
	var appContexts []*scheduler.Context
	var clusterUid string
	var clusterStatus api.ClusterInfo_StatusInfo_Status
	var customBackupLocationName string
	var credName string
	var fullBackupName string
	var incrementalBackupName string
	var bkpNamespaces = make([]string, 0)
	backupLocationMap := make(map[string]string)

	JustBeforeEach(func() {
		StartTorpedoTest("DeleteIncrementalBackupsAndRecreateNew",
			"Delete incremental Backups and re-create them", nil, 58039)
		log.InfoD("Deploy applications")

		contexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts = ScheduleApplications(taskName)
			contexts = append(contexts, appContexts...)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Delete incremental Backups and re-create them", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(contexts)
		})

		Step("Adding Credentials and Registering Backup Location", func() {
			log.InfoD("Creating cloud credentials and backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				customBackupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				err := CreateBackupLocation(provider, customBackupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", customBackupLocationName))
				backupLocationMap[backupLocationUID] = customBackupLocationName
				log.InfoD("Created Backup Location with name - %s", customBackupLocationName)
			}
		})

		Step("Register source and destination cluster for backup", func() {
			log.InfoD("Registering Source and Destination clusters and verifying the status")
			// Registering for admin user
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateSourceAndDestClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, "Creating source and destination cluster")
			clusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})

		Step("Taking backup of applications", func() {
			log.InfoD("Taking backup of applications")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			// Full backup
			for _, namespace := range bkpNamespaces {
				fullBackupName = fmt.Sprintf("%s-%s-%v", "full-backup", namespace, time.Now().Unix())
				backupNames = append(backupNames, fullBackupName)
				err = CreateBackup(fullBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup full [%s] creation", fullBackupName))
			}

			// Incremental backup
			for _, namespace := range bkpNamespaces {
				incrementalBackupName = fmt.Sprintf("%s-%s-%v", "incremental-backup", namespace, time.Now().Unix())
				incrementalBackupNames = append(incrementalBackupNames, incrementalBackupName)
				err = CreateBackup(incrementalBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup incremental [%s] creation", incrementalBackupName))
			}
			log.Infof("List of backups - %v", backupNames)
			log.Infof("List of Incremental backups - %v", incrementalBackupNames)

		})
		Step("Deleting incremental backup", func() {
			log.InfoD("Deleting incremental backups")
			backupDriver := Inst().Backup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range incrementalBackupNames {
				log.Infof("About to delete backup - %s", backupName)
				backupUID, err := backupDriver.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "Failed while trying to get backup UID for - %s", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting backup - [%s]", backupName))
			}
		})
		Step("Taking incremental backups of applications again", func() {
			log.InfoD("Taking incremental backups of applications again")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			// Incremental backup
			for _, namespace := range bkpNamespaces {
				incrementalBackupName = fmt.Sprintf("%s-%s-%v", "incremental-backup", namespace, time.Now().Unix())
				incrementalBackupNamesRecreated = append(incrementalBackupNamesRecreated, incrementalBackupName)
				err = CreateBackup(incrementalBackupName, SourceClusterName, customBackupLocationName, backupLocationUID, []string{namespace},
					labelSelectors, orgID, clusterUid, "", "", "", "", ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying incremental backup [%s] creation", incrementalBackupName))
			}
			log.Infof("List of New Incremental backups - %v", incrementalBackupNames)
		})
		Step("Check if backups are incremental backups or not", func() {
			log.InfoD("Check if backups are incremental backups or not")
			backupDriver := Inst().Backup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, incrementalBackupName := range incrementalBackupNamesRecreated {
				bkpUid, err := backupDriver.GetBackupUID(ctx, incrementalBackupName, orgID)
				log.FailOnError(err, "Unable to fetch backup UID - %s", incrementalBackupName)
				bkpInspectReq := &api.BackupInspectRequest{
					Name:  incrementalBackupName,
					OrgId: orgID,
					Uid:   bkpUid,
				}
				bkpInspectResponse, err := backupDriver.InspectBackup(ctx, bkpInspectReq)
				log.FailOnError(err, "Unable to fetch backup - %s", incrementalBackupName)
				for _, vol := range bkpInspectResponse.GetBackup().GetVolumes() {
					backupId := vol.GetBackupId()
					log.InfoD(fmt.Sprintf("Backup Name: %s; BackupID: %s", incrementalBackupName, backupId))
					dash.VerifyFatal(strings.Contains(backupId, "incr"), true,
						fmt.Sprintf("Check if the backup %s is incremental or not ", incrementalBackupName))
				}
			}
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(contexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		// Cleaning up applications created
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		ValidateAndDestroy(contexts, opts)

		// Cleaning up px-backup cluster
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})
