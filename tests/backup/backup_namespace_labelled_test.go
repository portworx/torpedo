package tests

import (
	"context"
	"fmt"
	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
	"sync"
	"time"
)

// NamespaceLabelledBackupWithDifferentUserRoles
var _ = Describe("{NamespaceLabelledBackupWithDifferentUserRoles}", func() {
	var (
		srcClusterUid     string
		backupLocationUID string
		cloudCredName     string
		cloudCredUID      string
		bkpLocationName   string
		backupNames       []string
		contexts          []*scheduler.Context
		appContexts       []*scheduler.Context
		srcClusterStatus  api.ClusterInfo_StatusInfo_Status
		destClusterStatus api.ClusterInfo_StatusInfo_Status
	)
	numberOfUsers := 3
	bkpNamespaces := make([]string, 0)
	restoreNames := make([]string, 0)
	users := make([]string, 0)
	groups := make([]string, 0)
	backupLocationMap := make(map[string]string)
	labels := make(map[string]string)
	userContextsList := make([]context.Context, 0)

	JustBeforeEach(func() {
		StartTorpedoTest("NamespaceLabelledBackupWithDifferentUserRoles",
			"Take namespace labelled backup and share with users having different access mode", nil, 85040)
		log.Infof("Deploy applications needed for backup")
		contexts = make([]*scheduler.Context, 0)
		// Here we have deployed 2*numberOfUsers namespaces/application
		for i := 0; i < numberOfUsers; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts = ScheduleApplications(taskName)
			contexts = append(contexts, appContexts...)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
		log.InfoD("List of all namespaces deployed are %v", bkpNamespaces)
	})
	It("Take namespace labelled backup and share with users having different access mode", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.Infof("Validate applications")
			ValidateApplications(contexts)
		})
		Step("Generating multiple labels", func() {
			log.InfoD("Generating multiple labels")
			labels = GenerateRandomLabels(numberOfUsers)
			log.InfoD("Generated labels are %v", labels)
		})
		Step("Adding labels to namespaces", func() {
			log.InfoD("Adding labels to only few namespaces")
			err := AddLabelsToMultipleNamespaces(labels, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to multiple namespaces [%v]", labels, bkpNamespaces))
		})
		Step("Create multiple users", func() {
			log.InfoD("Creating %d users", numberOfUsers)
			users = createUsers(numberOfUsers)
			log.Infof("Created %v users and users list is %v", numberOfUsers, users)
		})
		Step("Adding roles to each user", func() {
			log.InfoD("Adding roles to each user")
			err := backup.AddRoleToUser(users[0], backup.InfrastructureOwner, "")
			log.FailOnError(err, "Adding role to user %s is failed", users[0])
			err = backup.AddRoleToUser(users[1], backup.ApplicationOwner, "")
			log.FailOnError(err, "Adding role to user %s is failed", users[1])
			err = backup.AddRoleToUser(users[2], backup.ApplicationUser, "")
			log.FailOnError(err, "Adding role to user %s is failed", users[2])
		})
		Step("Creating backup location and cloud setting", func() {
			log.InfoD("Creating backup location and cloud setting")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredName = fmt.Sprintf("%s-%s-%v", "cred", provider, time.Now().Unix())
				bkpLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				backupLocationMap[backupLocationUID] = bkpLocationName
				err := CreateCloudCredential(provider, cloudCredName, cloudCredUID, orgID, ctx)
				log.FailOnError(err, fmt.Sprintf("Verifying creation of cloud credential named [%s] for org [%s] with [%s] as provider", cloudCredName, orgID, provider))
				err = CreateBackupLocation(provider, bkpLocationName, backupLocationUID, cloudCredName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				log.FailOnError(err, fmt.Sprintf("Creating backup location %s", bkpLocationName))
				err = UpdateBackupLocationOwnership(bkpLocationName, backupLocationUID, users, groups, api.Ownership_Read)
				log.FailOnError(err, fmt.Sprintf("Updating backup location %s ownership", bkpLocationName))
			}
		})
		Step("Starting the backup and restore with different user roles", func() {
			log.InfoD("Starting the backup and restore with different user roles")
			for _, userName := range users {
				log.InfoD("Registering sources and destination cluster for user %s", userName)
				log.InfoD("Common Password for User %s is %s", userName, commonPassword)
				ctxNonAdmin, err := backup.GetNonAdminCtx(userName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				userContextsList = append(userContextsList, ctxNonAdmin)
				err = CreateSourceAndDestClusters(orgID, "", "", ctxNonAdmin)
				log.FailOnError(err, "Creating source and destination cluster")
				srcClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctxNonAdmin)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				srcClusterUid, err = Inst().Backup.GetClusterUID(ctxNonAdmin, orgID, SourceClusterName)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
				destClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctxNonAdmin)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
				dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
				log.InfoD("Taking namespace labelled backup with user %s", userName)
				backupName := fmt.Sprintf("%s-%s", BackupNamePrefix, userName)
				backupNames = append(backupNames, backupName)
				err = CreateBackupWithNamespaceLabel(backupName, SourceClusterName, bkpLocationName, backupLocationUID,
					nil, orgID, srcClusterUid, "", "", "", "", MapToString(labels), ctxNonAdmin)
				log.FailOnError(err, "Failed while trying to take namespace labelled backup of applications %v", `bkpNamespaces`)
				log.InfoD("List of namespace labelled backups- %v", backupNames)
				err = NamespaceLabelBackupSuccessCheck(backupName, ctxNonAdmin, bkpNamespaces, MapToString(labels))
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", bkpNamespaces, MapToString(labels), backupName))

				log.InfoD("Restoring backup of single application")
				restoreName := fmt.Sprintf("%s-%s", RestoreNamePrefix, userName)
				err = CreateRestore(restoreName, backupName, nil, destinationClusterName, orgID, ctxNonAdmin, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore with name [%s] in default namespace", restoreName))
				restoreNames = append(restoreNames, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		var wg sync.WaitGroup
		defer EndPxBackupTorpedoTest(contexts)
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		ValidateAndDestroy(contexts, opts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.Infof("Deleting registered clusters for non-admin context")
		for _, ctxNonAdmin := range userContextsList {
			err := DeleteCluster(SourceClusterName, orgID, ctxNonAdmin)
			Inst().Dash.VerifySafely(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
			err = DeleteCluster(destinationClusterName, orgID, ctxNonAdmin)
			Inst().Dash.VerifySafely(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
		}
		log.Infof("Cleaning up users")
		for _, userName := range users {
			wg.Add(1)
			go func(userName string) {
				defer wg.Done()
				err := backup.DeleteUser(userName)
				dash.VerifySafely(err, nil, fmt.Sprintf("Deleting user %v", userName))
			}(userName)
		}
		wg.Wait()
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredName, cloudCredUID, ctx)
	})
})
