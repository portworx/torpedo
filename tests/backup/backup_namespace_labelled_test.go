package tests

import (
	"context"
	"fmt"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/sched-ops/k8s/core"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NamespaceLabelledBackupSharedWithDifferentAccessMode takes namespace labelled backup and share with users having different access mode
var _ = Describe("{NamespaceLabelledBackupSharedWithDifferentAccessMode}", func() {
	var (
		srcClusterUid            string
		backupLocationUID        string
		cloudCredName            string
		cloudCredUID             string
		bkpLocationName          string
		backupNames              []string
		listOfLabelledNamespaces []string
		scheduledAppContexts     []*scheduler.Context
		srcClusterStatus         api.ClusterInfo_StatusInfo_Status
		destClusterStatus        api.ClusterInfo_StatusInfo_Status
	)
	numberOfUsers := 3
	bkpNamespaces := make([]string, 0)
	users := make([]string, 0)
	backupLocationMap := make(map[string]string)
	labels := make(map[string]string)
	userContextsList := make([]context.Context, 0)
	userRestoreContext := make(map[context.Context]string)
	accessUserBackupContext := make(map[userAccessContext]string)

	JustBeforeEach(func() {
		StartTorpedoTest("NamespaceLabelledBackupSharedWithDifferentAccessMode",
			"Take namespace labelled backup and share with users having different access mode", nil, 85040)
		log.Infof("Deploy applications needed for backup")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		// Here we have deployed 2*numberOfUsers namespaces/application
		for i := 0; i < 2*numberOfUsers; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("List of all namespaces deployed are %v", bkpNamespaces)
	})
	It("Take namespace labelled backup and share with users having different access mode", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.Infof("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Generating multiple labels", func() {
			log.InfoD("Generating multiple labels")
			labels = GenerateRandomLabels(numberOfUsers)
			log.InfoD("Generated labels are %v", labels)
		})
		// Labelled only half of the namespaces
		Step("Adding labels to only few namespaces", func() {
			log.InfoD("Adding labels to only few namespaces")
			for i := 0; i < numberOfUsers; i++ {
				err := Inst().S.AddNamespaceLabel(bkpNamespaces[i], labels)
				log.FailOnError(err, "Failed to add labels %v to namespace %s", labels, bkpNamespaces[i])
				listOfLabelledNamespaces = append(listOfLabelledNamespaces, bkpNamespaces[i])
			}
			log.InfoD("List of labels applied namespaces are %v", listOfLabelledNamespaces)
		})
		Step("Create multiple users", func() {
			log.InfoD("Creating %d users", numberOfUsers)
			users = createUsers(numberOfUsers)
			log.Infof("Created %v users and users list is %v", numberOfUsers, users)
		})
		Step("Creating backup location and cloud setting", func() {
			log.InfoD("Creating backup location and cloud setting")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredName = fmt.Sprintf("%s-%s-%v", "cred", provider, time.Now().Unix())
				bkpLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				backupLocationMap[backupLocationUID] = bkpLocationName
				err := CreateCloudCredential(provider, cloudCredName, cloudCredUID, orgID, ctx)
				log.FailOnError(err, fmt.Sprintf("Verifying creation of cloud credential named [%s] for org [%s] with [%s] as provider", cloudCredName, orgID, provider))
				err = CreateBackupLocation(provider, bkpLocationName, backupLocationUID, cloudCredName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				log.FailOnError(err, fmt.Sprintf("Creating backup location %s", bkpLocationName))
			}
		})
		Step("Register source and destination cluster for backup", func() {
			log.InfoD("Register source and destination cluster for backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateSourceAndDestClusters(orgID, "", "", ctx)
			log.FailOnError(err, "Creating source and destination cluster")
			srcClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			destClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		// While taking namespace labelled backup, we are expecting that backup will be taken of only labelled namespaces, not all
		Step("Taking namespace labelled backup for each user", func() {
			log.InfoD("Taking namespace labelled backup for each user")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			var wg sync.WaitGroup
			for i := 0; i < numberOfUsers; i++ {
				backupName := fmt.Sprintf("%s-%v", BackupNamePrefix, users[i])
				backupNames = append(backupNames, backupName)
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, listOfLabelledNamespaces)
					err := CreateBackupWithNamespaceLabelWithValidation(ctx, backupName, SourceClusterName, bkpLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, srcClusterUid, "", "", "", "", MapToKeyValueString(labels))
					dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled backup [%s] of namespaces (scheduled contexts) [%v]", backupName, listOfLabelledNamespaces))
				}(backupName)
			}
			wg.Wait()
			log.InfoD("List of namespace labelled backups- %v", backupNames)
		})
		Step("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup", func() {
			log.InfoD("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range backupNames {
				err = NamespaceLabelBackupSuccessCheck(backupName, ctx, listOfLabelledNamespaces, MapToKeyValueString(labels))
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if only the labeled namespaces: [%v] are backed up and correct  labels [%s] are applied to backup [%s]", listOfLabelledNamespaces, MapToKeyValueString(labels), backupName))
			}
		})
		Step("Share backup with users with different access level", func() {
			log.InfoD("Share backup with users with different access level")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			accessUserBackupContext, err = ShareBackupWithUsersAndAccessAssignment(backupNames, users, ctx)
			log.FailOnError(err, fmt.Sprintf("Sharing backup %s with users %v", backupNames, users))
		})
		Step("Validate if the users with different access level can restore/delete backup as per their access mode", func() {
			log.InfoD("Validate if the users with different access level can restore/delete backup as per their access mode")
			for key, val := range accessUserBackupContext {
				restoreName := fmt.Sprintf("%s-%s-%v", key.user, RestoreNamePrefix, time.Now().Unix())
				access := key.accesses
				if access != ViewOnlyAccess {
					log.Infof("Adding the restores %v which will be created while validating %v access", restoreName, backupAccessKeyValue[access])
					userRestoreContext[key.context] = restoreName
				}
				ValidateSharedBackupWithUsers(key.user, key.accesses, val, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		var wg sync.WaitGroup
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting labels from namespaces - %v", listOfLabelledNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(labels, listOfLabelledNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] to namespaces [%v]", labels, listOfLabelledNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.Infof("Generating user context")
		for _, userName := range users {
			ctxNonAdmin, err := backup.GetNonAdminCtx(userName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			userContextsList = append(userContextsList, ctxNonAdmin)
		}
		log.Infof("Deleting restore created by users")
		for userContext, restoreName := range userRestoreContext {
			err = DeleteRestore(restoreName, orgID, userContext)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting Restore %s", restoreName))
		}
		log.Infof("Deleting registered clusters for non-admin context")
		for _, ctxNonAdmin := range userContextsList {
			CleanupCloudSettingsAndClusters(make(map[string]string), "", "", ctxNonAdmin)
		}
		log.Infof("Cleaning up users")
		for _, userName := range users {
			wg.Add(1)
			go func(userName string) {
				defer wg.Done()
				err := backup.DeleteUser(userName)
				dash.VerifySafely(err, nil, fmt.Sprintf("Deleting user %v", userName))
			}(userName)
		}
		wg.Wait()
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredName, cloudCredUID, ctx)
	})
})

// BackupScheduleForOldAndNewNS Schedule backup using namespace label for old namespace and new namespace
var _ = Describe("{BackupScheduleForOldAndNewNS}", func() {
	var (
		initialNSCount         int
		newNSCount             int
		scheduleInterval       int64
		err                    error
		backupLocationUID      string
		cloudCredUID           string
		clusterUid             string
		credName               string
		backupLocationName     string
		restoreName            string
		periodicSchPolicyName  string
		periodicSchPolicyUid   string
		scheduleName           string
		nsLabelString          string
		schBackupAfterAddingNS string
		bkpNamespaces          []string
		newNamespaces          []string
		cloudCredUidList       []string
		allScheduleBackupNames []string
		restoreNames           []string
		nsLabelsMap            map[string]string
		contexts               []*scheduler.Context
		appContexts            []*scheduler.Context
	)
	labelSelectors := make(map[string]string)
	backupLocationMap := make(map[string]string)
	namespaceMapping := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	initialNSCount = 3
	JustBeforeEach(func() {
		StartTorpedoTest("BackupScheduleForOldAndNewNS", "Schedule backup with old and new namespace using namespace label", nil, 84852)
		log.InfoD("Deploy applications")
		contexts = make([]*scheduler.Context, 0)
		for i := 0; i < initialNSCount; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts = ScheduleApplications(taskName)
			contexts = append(contexts, appContexts...)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Schedule backup using namespace label for old and new namespaces", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(contexts)
		})
		Step("Adding labels to namespaces", func() {
			log.InfoD("Adding labels to namespaces")
			nsLabelsMap = GenerateRandomLabels(20)
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%v]", nsLabelsMap, bkpNamespaces))
		})
		Step("Generating namespace label string from label map for namespaces", func() {
			log.InfoD("Generating namespace label string from label map for namespaces")
			nsLabelString = MapToKeyValueString(nsLabelsMap)
			log.Infof("label string for namespaces %s", nsLabelString)
		})
		Step("Adding labels to resources", func() {
			log.InfoD("Adding labels to resources")
			labelKey := uuid.New()
			labelValue := uuid.New()
			labelSelectors[labelKey] = labelValue
			for _, namespace := range bkpNamespaces {
				pvcList, err := core.Instance().GetPersistentVolumeClaims(namespace, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc list [%v] from namespace [%s]", pvcList, namespace))
				for _, pvc := range pvcList.Items {
					pvcItem, err := core.Instance().GetPersistentVolumeClaim(pvc.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc pointer %v for pvc %v", pvcItem, pvc))
					err = AddLabelToResource(pvcItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, pvcItem))
				}
				cmList, err := core.Instance().ListConfigMap(namespace, meta_v1.ListOptions{})
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap list [%v] from namespace [%s]", cmList, namespace))
				for _, cm := range cmList.Items {
					cmItem, err := core.Instance().GetConfigMap(cm.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap pointer %v from namespace %s", cmItem, namespace))
					err = AddLabelToResource(cmItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, cmItem))
				}
			}
		})
		Step("Creating cloud credentials and backup location", func() {
			log.InfoD("Creating cloud credentials and registering backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err := CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credentials %s with provider %s", credName, provider))
				log.InfoD("Created cloud credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err = CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Add source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Adding source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateSourceAndDestClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of source [%s] and destination [%s] clusters", SourceClusterName, destinationClusterName))
			appClusterName := destinationClusterName
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, appClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", appClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", appClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, appClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", appClusterName))
			log.InfoD("Uid of [%s] cluster is %s", appClusterName, clusterUid)
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			scheduleInterval = 15
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			periodicSchPolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchPolicyUid = uuid.New()
			periodicSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, scheduleInterval, 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchPolicyName, periodicSchPolicyUid, orgID, periodicSchedulePolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval 15 minutes named [%s]", periodicSchPolicyName))
			periodicSchPolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchPolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchPolicyName))
		})
		Step("Creating a schedule backup using namespace label and resource label", func() {
			log.InfoD("Creating a schedule backup using namespace label and resource label")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			scheduleName = fmt.Sprintf("%s-schedule-%v", BackupNamePrefix, time.Now().Unix())
			err = CreateScheduleBackupWithNamespaceLabel(scheduleName, SourceClusterName, backupLocationName, backupLocationUID,
				labelSelectors, orgID, "", "", "", "", nsLabelString, periodicSchPolicyName, periodicSchPolicyUid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of schedule backup with schedule name [%s]", scheduleName))
			firstSchBackupName, err := GetFirstScheduleBackupName(ctx, scheduleName, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the first schedule backup [%s]", firstSchBackupName))
			err = NamespaceLabelBackupSuccessCheck(firstSchBackupName, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespaces [%v] are backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, firstSchBackupName))
			log.InfoD("Waiting for %v minutes for the next schedule backup to be triggered", scheduleInterval)
			time.Sleep(time.Duration(scheduleInterval) * time.Minute)
			secondSchBackupName, err := GetOrdinalScheduleBackupName(ctx, scheduleName, 2, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", secondSchBackupName))
			err = NamespaceLabelBackupSuccessCheck(secondSchBackupName, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespace [%v] is backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, secondSchBackupName))
		})
		Step("Schedule applications to create new namespaces", func() {
			log.InfoD("Scheduling applications to create new namespaces")
			contexts = make([]*scheduler.Context, 0)
			newNSCount = 2
			for i := 0; i < newNSCount; i++ {
				taskName := fmt.Sprintf("%s-%d", "new-namespace", i)
				appContexts := ScheduleApplications(taskName)
				contexts = append(contexts, appContexts...)
				for _, ctx := range appContexts {
					ctx.ReadinessTimeout = appReadinessTimeout
					namespace := GetAppNamespace(ctx, taskName)
					log.InfoD("Scheduled application with namespace [%s]", namespace)
					newNamespaces = append(newNamespaces, namespace)
				}
			}
		})
		Step("Validate new namespaces", func() {
			log.InfoD("Validating new namespaces")
			ValidateApplications(contexts)
		})
		Step("Apply same namespace labels to new namespaces", func() {
			log.InfoD("Apply same namespace labels to new namespaces")
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, newNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Applying same namespace labels %v to new namespace %v", nsLabelsMap, newNamespaces))
		})
		Step("Verify new application namespaces with same namespace label are included in next schedule backup", func() {
			log.InfoD("Verifying new applications namespace new application namespaces with same namespace label are included in next schedule backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			schBackupAfterAddingNS, err = GetNextPeriodicScheduleBackupName(scheduleName, time.Duration(scheduleInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup success for %s schedule backup", schBackupAfterAddingNS))
			bkpNamespaces = append(bkpNamespaces, newNamespaces...)
			log.InfoD("Total namespaces are [%v]", bkpNamespaces)
			err = NamespaceLabelBackupSuccessCheck(schBackupAfterAddingNS, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespace [%v] is backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, schBackupAfterAddingNS))
		})
		Step("Restoring scheduled backups", func() {
			log.InfoD("Restoring scheduled backups")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			allScheduleBackupNames, err = Inst().Backup.GetAllScheduleBackupNames(ctx, scheduleName, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching names of all schedule backups of schedule named [%s]", scheduleName))
			for _, backupName := range allScheduleBackupNames {
				restoreName = fmt.Sprintf("%s-%s-%v", restoreNamePrefix, scheduleName, time.Now().Unix())
				err = CreateRestore(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, ctx, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups - %s", restoreName))
				restoreNames = append(restoreNames, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(contexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		dash.VerifySafely(err, nil, "Fetching px-central-admin ctx")
		err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchPolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchPolicyName}))
		for _, restoreName := range restoreNames {
			err = DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting restore [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces- %v", bkpNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsMap, bkpNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsMap, bkpNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(contexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})
