package tests

import (
	"context"
	"fmt"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// NamespaceLabelledBackupSharedWithDifferentAccessMode takes namespace labelled backup and share with users having different access mode
var _ = Describe("{NamespaceLabelledBackupSharedWithDifferentAccessMode}", func() {
	var (
		srcClusterUid            string
		backupLocationUID        string
		cloudCredName            string
		cloudCredUID             string
		bkpLocationName          string
		backupNames              []string
		listOfLabelledNamespaces []string
		scheduledAppContexts     []*scheduler.Context
		srcClusterStatus         api.ClusterInfo_StatusInfo_Status
		destClusterStatus        api.ClusterInfo_StatusInfo_Status
	)
	numberOfUsers := 3
	bkpNamespaces := make([]string, 0)
	users := make([]string, 0)
	backupLocationMap := make(map[string]string)
	labels := make(map[string]string)
	userContextsList := make([]context.Context, 0)
	userRestoreContext := make(map[context.Context]string)
	accessUserBackupContext := make(map[userAccessContext]string)

	JustBeforeEach(func() {
		StartTorpedoTest("NamespaceLabelledBackupSharedWithDifferentAccessMode",
			"Take namespace labelled backup and share with users having different access mode", nil, 85040)
		log.Infof("Deploy applications needed for backup")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		// Here we have deployed 2*numberOfUsers namespaces/application
		for i := 0; i < 2*numberOfUsers; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("List of all namespaces deployed are %v", bkpNamespaces)
	})
	It("Take namespace labelled backup and share with users having different access mode", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.Infof("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Generating multiple labels", func() {
			log.InfoD("Generating multiple labels")
			labels = GenerateRandomLabels(numberOfUsers)
			log.InfoD("Generated labels are %v", labels)
		})
		// Labelled only half of the namespaces
		Step("Adding labels to only few namespaces", func() {
			log.InfoD("Adding labels to only few namespaces")
			for i := 0; i < numberOfUsers; i++ {
				err := Inst().S.AddNamespaceLabel(bkpNamespaces[i], labels)
				log.FailOnError(err, "Failed to add labels %v to namespace %s", labels, bkpNamespaces[i])
				listOfLabelledNamespaces = append(listOfLabelledNamespaces, bkpNamespaces[i])
			}
			log.InfoD("List of labels applied namespaces are %v", listOfLabelledNamespaces)
		})
		Step("Create multiple users", func() {
			log.InfoD("Creating %d users", numberOfUsers)
			users = createUsers(numberOfUsers)
			log.Infof("Created %v users and users list is %v", numberOfUsers, users)
		})
		Step("Creating backup location and cloud setting", func() {
			log.InfoD("Creating backup location and cloud setting")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredName = fmt.Sprintf("%s-%s-%v", "cred", provider, time.Now().Unix())
				bkpLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				backupLocationMap[backupLocationUID] = bkpLocationName
				err := CreateCloudCredential(provider, cloudCredName, cloudCredUID, orgID, ctx)
				log.FailOnError(err, fmt.Sprintf("Verifying creation of cloud credential named [%s] for org [%s] with [%s] as provider", cloudCredName, orgID, provider))
				err = CreateBackupLocation(provider, bkpLocationName, backupLocationUID, cloudCredName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				log.FailOnError(err, fmt.Sprintf("Creating backup location %s", bkpLocationName))
			}
		})
		Step("Register source and destination cluster for backup", func() {
			log.InfoD("Register source and destination cluster for backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateSourceAndDestClusters(orgID, "", "", ctx)
			log.FailOnError(err, "Creating source and destination cluster")
			srcClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			destClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		// While taking namespace labelled backup, we are expecting that backup will be taken of only labelled namespaces, not all
		Step("Taking namespace labelled backup for each user", func() {
			log.InfoD("Taking namespace labelled backup for each user")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			var wg sync.WaitGroup
			for i := 0; i < numberOfUsers; i++ {
				backupName := fmt.Sprintf("%s-%v", BackupNamePrefix, users[i])
				backupNames = append(backupNames, backupName)
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, listOfLabelledNamespaces)
					err := CreateBackupWithNamespaceLabelWithValidation(ctx, backupName, SourceClusterName, bkpLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, srcClusterUid, "", "", "", "", MapToKeyValueString(labels))
					dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled backup [%s] of namespaces (scheduled contexts) [%v]", backupName, listOfLabelledNamespaces))
				}(backupName)
			}
			wg.Wait()
			log.InfoD("List of namespace labelled backups- %v", backupNames)
		})
		Step("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup", func() {
			log.InfoD("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range backupNames {
				err = NamespaceLabelBackupSuccessCheck(backupName, ctx, listOfLabelledNamespaces, MapToKeyValueString(labels))
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if only the labeled namespaces: [%v] are backed up and correct  labels [%s] are applied to backup [%s]", listOfLabelledNamespaces, MapToKeyValueString(labels), backupName))
			}
		})
		Step("Share backup with users with different access level", func() {
			log.InfoD("Share backup with users with different access level")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			accessUserBackupContext, err = ShareBackupWithUsersAndAccessAssignment(backupNames, users, ctx)
			log.FailOnError(err, fmt.Sprintf("Sharing backup %s with users %v", backupNames, users))
		})
		Step("Validate if the users with different access level can restore/delete backup as per their access mode", func() {
			log.InfoD("Validate if the users with different access level can restore/delete backup as per their access mode")
			for key, val := range accessUserBackupContext {
				restoreName := fmt.Sprintf("%s-%s-%v", key.user, RestoreNamePrefix, time.Now().Unix())
				access := key.accesses
				if access != ViewOnlyAccess {
					log.Infof("Adding the restores %v which will be created while validating %v access", restoreName, backupAccessKeyValue[access])
					userRestoreContext[key.context] = restoreName
				}
				ValidateSharedBackupWithUsers(key.user, key.accesses, val, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		var wg sync.WaitGroup
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting labels from namespaces - %v", listOfLabelledNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(labels, listOfLabelledNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] to namespaces [%v]", labels, listOfLabelledNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.Infof("Generating user context")
		for _, userName := range users {
			ctxNonAdmin, err := backup.GetNonAdminCtx(userName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			userContextsList = append(userContextsList, ctxNonAdmin)
		}
		log.Infof("Deleting restore created by users")
		for userContext, restoreName := range userRestoreContext {
			err = DeleteRestore(restoreName, orgID, userContext)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting Restore %s", restoreName))
		}
		log.Infof("Deleting registered clusters for non-admin context")
		for _, ctxNonAdmin := range userContextsList {
			CleanupCloudSettingsAndClusters(make(map[string]string), "", "", ctxNonAdmin)
		}
		log.Infof("Cleaning up users")
		for _, userName := range users {
			wg.Add(1)
			go func(userName string) {
				defer wg.Done()
				err := backup.DeleteUser(userName)
				dash.VerifySafely(err, nil, fmt.Sprintf("Deleting user %v", userName))
			}(userName)
		}
		wg.Wait()
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredName, cloudCredUID, ctx)
	})
})
