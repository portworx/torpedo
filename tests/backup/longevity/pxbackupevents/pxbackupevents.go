package pxbackupevents

import (
	"fmt"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
	. "github.com/portworx/torpedo/tests/backup/longevity/pxbackuplongevitytypes"
)

const (
	EventBuilder1                       = "EventBuilder1"
	EventBuilder1Fail                   = "EventBuilder1Fail"
	EventScheduleApps                   = "eventScheduleApps"
	EventValidateScheduleApplication    = "EventValidateScheduleApplication"
	EventAddCredentialandBackupLocation = "EventAddCredentialandBackupLocation"
	EventAddSourceAndDestinationCluster = "EventAddSourceAndDestinationCluster"
	EventCreateBackup                   = "EventCreateBackup"
)

var ctx, _ = backup.GetAdminCtxFromSecret()

type PxBackupEventBuilder func(*PxBackupLongevity) (error, string, EventData)

func eventScheduleApps(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	defer GinkgoRecover()
	eventData := &EventData{}

	var scheduledAppContexts = make([]*scheduler.Context, 0)
	var bkpNamespaces = make([]string, 0)

	for i := 0; i < Inst().GlobalScaleFactor; i++ {
		taskName := fmt.Sprintf("%s-%d-%s", taskNamePrefix, i, RandomString(5))
		appContexts := ScheduleApplications(taskName)
		for _, ctx := range appContexts {
			ctx.ReadinessTimeout = appReadinessTimeout
			namespace := GetAppNamespace(ctx, taskName)
			bkpNamespaces = append(bkpNamespaces, namespace)
			scheduledAppContexts = append(scheduledAppContexts, ctx)
		}
	}

	eventData.BackupNamespaces = bkpNamespaces
	eventData.SchedulerContext = scheduledAppContexts

	return nil, "", *eventData
}

func eventValidateScheduleApplication(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	defer GinkgoRecover()
	eventData := &EventData{}
	ValidateApplications(inputsForEventBuilder.ApplicationData.SchedulerContext)
	return nil, "", *eventData
}

func eventAddCredentialandBackupLocation(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	defer GinkgoRecover()
	eventData := &EventData{}
	backupLocationMap := make(map[string]string)
	var cloudCredUidList []string
	var providers = getProviders()
	var backupLocationUID string

	log.InfoD("Creating cloud credentials and backup location")
	for _, provider := range providers {
		cloudCredUID := uuid.New()
		cloudCredUidList = append(cloudCredUidList, cloudCredUID)
		backupLocationUID = uuid.New()
		credName := fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
		err := CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
		if err != nil {
			return err, "", *eventData
		}
		log.InfoD("Created Cloud Credentials with name - %s", credName)
		customBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
		err = CreateBackupLocation(provider, customBackupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", true)
		if err != nil {
			return err, "", *eventData
		}
		backupLocationMap[backupLocationUID] = customBackupLocationName
		log.InfoD("Created Backup Location with name - %s", customBackupLocationName)

		eventData.BackupLocationName = customBackupLocationName
		eventData.BackupLocationUID = backupLocationUID
	}

	return nil, "", *eventData
}

func eventAddSourceAndDestinationCluster(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	defer GinkgoRecover()
	eventData := &EventData{}

	log.Infof("Adding Clusters for backup")
	err := CreateApplicationClusters(orgID, "", "", ctx)
	if err != nil {
		return err, "", *eventData
	}
	clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
	if err != nil {
		return err, "", *eventData
	}
	if clusterStatus != api.ClusterInfo_StatusInfo_Online {
		return fmt.Errorf("Cluster %s is not online", SourceClusterName), fmt.Sprintf("Cluster added but not online"), *eventData
	}

	clusterUid, err := Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
	if err != nil {
		return err, "", *eventData
	}
	eventData.ClusterUid = clusterUid

	return nil, "", *eventData
}

func eventCreateBackup(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	defer GinkgoRecover()

	eventData := &EventData{}
	var backupNames []string

	log.Infof("Creating a manual backup")
	for _, namespace := range inputsForEventBuilder.BackupData.Namespaces {
		backupName := fmt.Sprintf("%s-%v-%s", BackupNamePrefix, time.Now().Unix(), RandomString(10))
		labelSelectors := make(map[string]string)
		appContextsToBackup := FilterAppContextsByNamespace(inputsForEventBuilder.ApplicationData.SchedulerContext, []string{namespace})
		err := CreateBackupWithValidation(
			ctx,
			backupName,
			SourceClusterName,
			inputsForEventBuilder.BackupData.BackupLocationName,
			inputsForEventBuilder.BackupData.BackupLocationUID,
			appContextsToBackup,
			labelSelectors,
			orgID,
			inputsForEventBuilder.BackupData.ClusterUid, "", "", "", "")
		if err != nil {
			return err, "Error occurred while taking backup", *eventData
		}
		backupNames = append(backupNames, backupName)
	}

	eventData.BackupNames = backupNames

	return nil, "", *eventData
}

func eventBuilder1(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	eventData := &EventData{}
	time.Sleep(time.Second * time.Duration(inputsForEventBuilder.CustomData.Integers["timeToBlock"]))
	return nil, "", *eventData
}

func eventBuilder1Fail(inputsForEventBuilder *PxBackupLongevity) (error, string, EventData) {
	eventData := &EventData{}
	time.Sleep(time.Second * time.Duration(inputsForEventBuilder.CustomData.Integers["timeToBlock"]))
	return fmt.Errorf("This is the returned error"), "This is the highlight event from - EventBuilder1Fail", *eventData
}

func RunBuilder(eventBuilderName string, inputsForEventBuilder *PxBackupLongevity, eventResponse *EventResponse) EventData {
	defer GinkgoRecover()
	eventBuilder := AllBuilders[eventBuilderName]
	eventBuilderIdentifier := eventBuilderName + "-" + time.Now().Format("15:04:05.000")
	eventResponse.EventBuilders[eventBuilderIdentifier] = &EventBuilderResponse{}

	startTime := time.Now()

	err, highlightEvent, eventData := eventBuilder(inputsForEventBuilder)
	if err != nil {
		eventResponse.EventBuilders[eventBuilderIdentifier].Error = err
	}
	if highlightEvent != "" {
		eventResponse.EventBuilders[eventBuilderIdentifier].HighlightEvent = highlightEvent
	}
	eventResponse.EventBuilders[eventBuilderIdentifier].EventData = eventData
	eventResponse.EventBuilders[eventBuilderIdentifier].TimeTakenInMinutes = float32(time.Since(startTime).Minutes())

	return eventData
}

// Helpers for events

func getGlobalBucketName(provider string) string {
	var bucketName string
	switch provider {
	case drivers.ProviderAws:
		bucketName = fmt.Sprintf("%s-%s", globalAWSBucketPrefix, "pxb-ssie")
	case drivers.ProviderAzure:
		bucketName = fmt.Sprintf("%s-%s", globalAzureBucketName, "pxb-ssie")
	case drivers.ProviderGke:
		bucketName = fmt.Sprintf("%s-%s", globalGCPBucketPrefix, "pxb-ssie")
	case drivers.ProviderNfs:
		bucketName = fmt.Sprintf("%s-%s", globalGCPBucketPrefix, "pxb-ssie")
	default:
		bucketName = fmt.Sprintf("%s-%s", "default", "pxb-ssie")
	}
	CreateBucket(bucketName, provider)
	log.Infof("Bucket created with name - %s", globalAWSBucketName)
	return bucketName
}
